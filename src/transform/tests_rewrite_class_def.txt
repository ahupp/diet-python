$ lowers simple class

class C:
    x = 1
=
def _dp_ns_C(_dp_prepare_ns):
    _dp_class_annotations = _dp_prepare_ns.get("__annotations__")
    _dp_tmp_2 = __dp__.is_(_dp_class_annotations, None)
    if _dp_tmp_2:
        _dp_class_annotations = __dp__.dict()
    _dp_var_x_1 = 1
    return __dp__.list((("__module__", __name__), ("__qualname__", "C"), ("x", _dp_var_x_1)))
def _dp_make_class_C():
    orig_bases = ()
    bases = __dp__.resolve_bases(orig_bases)
    _dp_tmp_3 = __dp__.prepare_class("C", bases, None)
    meta = __dp__.getitem(_dp_tmp_3, 0)
    ns = __dp__.getitem(_dp_tmp_3, 1)
    kwds = __dp__.getitem(_dp_tmp_3, 2)
    _dp_namespace_entries = _dp_ns_C(ns)
    _dp_temp_ns = __dp__.dict()
    _dp_iter_4 = __dp__.iter(_dp_namespace_entries)
    while True:
        try:
            _dp_tmp_5 = __dp__.next(_dp_iter_4)
            _dp_name = __dp__.getitem(_dp_tmp_5, 0)
            _dp_value = __dp__.getitem(_dp_tmp_5, 1)
        except:
            __dp__.check_stopiteration()
            break
        else:
            __dp__.setitem(_dp_temp_ns, _dp_name, _dp_value)
            __dp__.setitem(ns, _dp_name, _dp_value)
    _dp_tmp_7 = __dp__.is_not(orig_bases, bases)
    _dp_tmp_6 = _dp_tmp_7
    if _dp_tmp_6:
        _dp_tmp_8 = __dp__.not_(__dp__.contains(ns, "__orig_bases__"))
        _dp_tmp_6 = _dp_tmp_8
    if _dp_tmp_6:
        __dp__.setitem(ns, "__orig_bases__", orig_bases)
    return meta("C", bases, ns, **kwds)
_dp_class_C = _dp_make_class_C()
C = _dp_class_C
$ collects class annotations

class C:
    x: int
    y: str = 1
=
def _dp_ns_C(_dp_prepare_ns):
    _dp_class_annotations = _dp_prepare_ns.get("__annotations__")
    _dp_tmp_3 = __dp__.is_(_dp_class_annotations, None)
    if _dp_tmp_3:
        _dp_class_annotations = __dp__.dict()
    __dp__.setitem(_dp_class_annotations, "x", int)
    _dp_var_y_2 = 1
    __dp__.setitem(_dp_class_annotations, "y", str)
    return __dp__.list((("__module__", __name__), ("__qualname__", "C"), ("__annotations__", _dp_class_annotations), ("y", _dp_var_y_2)))
def _dp_make_class_C():
    orig_bases = ()
    bases = __dp__.resolve_bases(orig_bases)
    _dp_tmp_4 = __dp__.prepare_class("C", bases, None)
    meta = __dp__.getitem(_dp_tmp_4, 0)
    ns = __dp__.getitem(_dp_tmp_4, 1)
    kwds = __dp__.getitem(_dp_tmp_4, 2)
    _dp_namespace_entries = _dp_ns_C(ns)
    _dp_temp_ns = __dp__.dict()
    _dp_iter_5 = __dp__.iter(_dp_namespace_entries)
    while True:
        try:
            _dp_tmp_6 = __dp__.next(_dp_iter_5)
            _dp_name = __dp__.getitem(_dp_tmp_6, 0)
            _dp_value = __dp__.getitem(_dp_tmp_6, 1)
        except:
            __dp__.check_stopiteration()
            break
        else:
            __dp__.setitem(_dp_temp_ns, _dp_name, _dp_value)
            __dp__.setitem(ns, _dp_name, _dp_value)
    _dp_tmp_8 = __dp__.is_not(orig_bases, bases)
    _dp_tmp_7 = _dp_tmp_8
    if _dp_tmp_7:
        _dp_tmp_9 = __dp__.not_(__dp__.contains(ns, "__orig_bases__"))
        _dp_tmp_7 = _dp_tmp_9
    if _dp_tmp_7:
        __dp__.setitem(ns, "__orig_bases__", orig_bases)
    return meta("C", bases, ns, **kwds)
_dp_class_C = _dp_make_class_C()
C = _dp_class_C
$ captures outer reference

class C:
    x = x
=
def _dp_ns_C(_dp_prepare_ns):
    _dp_class_annotations = _dp_prepare_ns.get("__annotations__")
    _dp_tmp_2 = __dp__.is_(_dp_class_annotations, None)
    if _dp_tmp_2:
        _dp_class_annotations = __dp__.dict()
    _dp_var_x_1 = x
    return __dp__.list((("__module__", __name__), ("__qualname__", "C"), ("x", _dp_var_x_1)))
def _dp_make_class_C():
    orig_bases = ()
    bases = __dp__.resolve_bases(orig_bases)
    _dp_tmp_3 = __dp__.prepare_class("C", bases, None)
    meta = __dp__.getitem(_dp_tmp_3, 0)
    ns = __dp__.getitem(_dp_tmp_3, 1)
    kwds = __dp__.getitem(_dp_tmp_3, 2)
    _dp_namespace_entries = _dp_ns_C(ns)
    _dp_temp_ns = __dp__.dict()
    _dp_iter_4 = __dp__.iter(_dp_namespace_entries)
    while True:
        try:
            _dp_tmp_5 = __dp__.next(_dp_iter_4)
            _dp_name = __dp__.getitem(_dp_tmp_5, 0)
            _dp_value = __dp__.getitem(_dp_tmp_5, 1)
        except:
            __dp__.check_stopiteration()
            break
        else:
            __dp__.setitem(_dp_temp_ns, _dp_name, _dp_value)
            __dp__.setitem(ns, _dp_name, _dp_value)
    _dp_tmp_7 = __dp__.is_not(orig_bases, bases)
    _dp_tmp_6 = _dp_tmp_7
    if _dp_tmp_6:
        _dp_tmp_8 = __dp__.not_(__dp__.contains(ns, "__orig_bases__"))
        _dp_tmp_6 = _dp_tmp_8
    if _dp_tmp_6:
        __dp__.setitem(ns, "__orig_bases__", orig_bases)
    return meta("C", bases, ns, **kwds)
_dp_class_C = _dp_make_class_C()
C = _dp_class_C
$ captures names used in annotations

T = object()

class C:
    x: T
=
T = object()
def _dp_ns_C(_dp_prepare_ns):
    _dp_class_annotations = _dp_prepare_ns.get("__annotations__")
    _dp_tmp_2 = __dp__.is_(_dp_class_annotations, None)
    if _dp_tmp_2:
        _dp_class_annotations = __dp__.dict()
    __dp__.setitem(_dp_class_annotations, "x", T)
    return __dp__.list((("__module__", __name__), ("__qualname__", "C"), ("__annotations__", _dp_class_annotations)))
def _dp_make_class_C():
    orig_bases = ()
    bases = __dp__.resolve_bases(orig_bases)
    _dp_tmp_3 = __dp__.prepare_class("C", bases, None)
    meta = __dp__.getitem(_dp_tmp_3, 0)
    ns = __dp__.getitem(_dp_tmp_3, 1)
    kwds = __dp__.getitem(_dp_tmp_3, 2)
    _dp_namespace_entries = _dp_ns_C(ns)
    _dp_temp_ns = __dp__.dict()
    _dp_iter_4 = __dp__.iter(_dp_namespace_entries)
    while True:
        try:
            _dp_tmp_5 = __dp__.next(_dp_iter_4)
            _dp_name = __dp__.getitem(_dp_tmp_5, 0)
            _dp_value = __dp__.getitem(_dp_tmp_5, 1)
        except:
            __dp__.check_stopiteration()
            break
        else:
            __dp__.setitem(_dp_temp_ns, _dp_name, _dp_value)
            __dp__.setitem(ns, _dp_name, _dp_value)
    _dp_tmp_7 = __dp__.is_not(orig_bases, bases)
    _dp_tmp_6 = _dp_tmp_7
    if _dp_tmp_6:
        _dp_tmp_8 = __dp__.not_(__dp__.contains(ns, "__orig_bases__"))
        _dp_tmp_6 = _dp_tmp_8
    if _dp_tmp_6:
        __dp__.setitem(ns, "__orig_bases__", orig_bases)
    return meta("C", bases, ns, **kwds)
_dp_class_C = _dp_make_class_C()
C = _dp_class_C
$ preserves class locals for references

class C:
    x = 1
    y = x
=
def _dp_ns_C(_dp_prepare_ns):
    _dp_class_annotations = _dp_prepare_ns.get("__annotations__")
    _dp_tmp_3 = __dp__.is_(_dp_class_annotations, None)
    if _dp_tmp_3:
        _dp_class_annotations = __dp__.dict()
    _dp_var_x_1 = 1
    _dp_var_y_2 = _dp_var_x_1
    return __dp__.list((("__module__", __name__), ("__qualname__", "C"), ("x", _dp_var_x_1), ("y", _dp_var_y_2)))
def _dp_make_class_C():
    orig_bases = ()
    bases = __dp__.resolve_bases(orig_bases)
    _dp_tmp_4 = __dp__.prepare_class("C", bases, None)
    meta = __dp__.getitem(_dp_tmp_4, 0)
    ns = __dp__.getitem(_dp_tmp_4, 1)
    kwds = __dp__.getitem(_dp_tmp_4, 2)
    _dp_namespace_entries = _dp_ns_C(ns)
    _dp_temp_ns = __dp__.dict()
    _dp_iter_5 = __dp__.iter(_dp_namespace_entries)
    while True:
        try:
            _dp_tmp_6 = __dp__.next(_dp_iter_5)
            _dp_name = __dp__.getitem(_dp_tmp_6, 0)
            _dp_value = __dp__.getitem(_dp_tmp_6, 1)
        except:
            __dp__.check_stopiteration()
            break
        else:
            __dp__.setitem(_dp_temp_ns, _dp_name, _dp_value)
            __dp__.setitem(ns, _dp_name, _dp_value)
    _dp_tmp_8 = __dp__.is_not(orig_bases, bases)
    _dp_tmp_7 = _dp_tmp_8
    if _dp_tmp_7:
        _dp_tmp_9 = __dp__.not_(__dp__.contains(ns, "__orig_bases__"))
        _dp_tmp_7 = _dp_tmp_9
    if _dp_tmp_7:
        __dp__.setitem(ns, "__orig_bases__", orig_bases)
    return meta("C", bases, ns, **kwds)
_dp_class_C = _dp_make_class_C()
C = _dp_class_C
$ lowers inherits

class C(B):
    pass
=
def _dp_ns_C(_dp_prepare_ns):
    _dp_class_annotations = _dp_prepare_ns.get("__annotations__")
    _dp_tmp_1 = __dp__.is_(_dp_class_annotations, None)
    if _dp_tmp_1:
        _dp_class_annotations = __dp__.dict()
    return __dp__.list((("__module__", __name__), ("__qualname__", "C")))
def _dp_make_class_C():
    orig_bases = B,
    bases = __dp__.resolve_bases(orig_bases)
    _dp_tmp_2 = __dp__.prepare_class("C", bases, None)
    meta = __dp__.getitem(_dp_tmp_2, 0)
    ns = __dp__.getitem(_dp_tmp_2, 1)
    kwds = __dp__.getitem(_dp_tmp_2, 2)
    _dp_namespace_entries = _dp_ns_C(ns)
    _dp_temp_ns = __dp__.dict()
    _dp_iter_3 = __dp__.iter(_dp_namespace_entries)
    while True:
        try:
            _dp_tmp_4 = __dp__.next(_dp_iter_3)
            _dp_name = __dp__.getitem(_dp_tmp_4, 0)
            _dp_value = __dp__.getitem(_dp_tmp_4, 1)
        except:
            __dp__.check_stopiteration()
            break
        else:
            __dp__.setitem(_dp_temp_ns, _dp_name, _dp_value)
            __dp__.setitem(ns, _dp_name, _dp_value)
    _dp_tmp_6 = __dp__.is_not(orig_bases, bases)
    _dp_tmp_5 = _dp_tmp_6
    if _dp_tmp_5:
        _dp_tmp_7 = __dp__.not_(__dp__.contains(ns, "__orig_bases__"))
        _dp_tmp_5 = _dp_tmp_7
    if _dp_tmp_5:
        __dp__.setitem(ns, "__orig_bases__", orig_bases)
    return meta("C", bases, ns, **kwds)
_dp_class_C = _dp_make_class_C()
C = _dp_class_C
$ lowers with docstring and keywords

class C(B, metaclass=Meta, kw=1):
    'doc'
    x = 2
=
def _dp_ns_C(_dp_prepare_ns):
    __doc__ = 'doc'
    _dp_class_annotations = _dp_prepare_ns.get("__annotations__")
    _dp_tmp_2 = __dp__.is_(_dp_class_annotations, None)
    if _dp_tmp_2:
        _dp_class_annotations = __dp__.dict()
    _dp_var_x_1 = 2
    return __dp__.list((("__module__", __name__), ("__qualname__", "C"), ("__doc__", __doc__), ("x", _dp_var_x_1)))
def _dp_make_class_C():
    orig_bases = B,
    bases = __dp__.resolve_bases(orig_bases)
    _dp_tmp_3 = __dp__.prepare_class("C", bases, __dp__.dict((("metaclass", Meta), ("kw", 1))))
    meta = __dp__.getitem(_dp_tmp_3, 0)
    ns = __dp__.getitem(_dp_tmp_3, 1)
    kwds = __dp__.getitem(_dp_tmp_3, 2)
    _dp_namespace_entries = _dp_ns_C(ns)
    _dp_temp_ns = __dp__.dict()
    _dp_iter_4 = __dp__.iter(_dp_namespace_entries)
    while True:
        try:
            _dp_tmp_5 = __dp__.next(_dp_iter_4)
            _dp_name = __dp__.getitem(_dp_tmp_5, 0)
            _dp_value = __dp__.getitem(_dp_tmp_5, 1)
        except:
            __dp__.check_stopiteration()
            break
        else:
            __dp__.setitem(_dp_temp_ns, _dp_name, _dp_value)
            __dp__.setitem(ns, _dp_name, _dp_value)
    _dp_tmp_7 = __dp__.is_not(orig_bases, bases)
    _dp_tmp_6 = _dp_tmp_7
    if _dp_tmp_6:
        _dp_tmp_8 = __dp__.not_(__dp__.contains(ns, "__orig_bases__"))
        _dp_tmp_6 = _dp_tmp_8
    if _dp_tmp_6:
        __dp__.setitem(ns, "__orig_bases__", orig_bases)
    return meta("C", bases, ns, **kwds)
_dp_class_C = _dp_make_class_C()
C = _dp_class_C
$ lowers method

class C:
    def m(self):
        return 1
=
def _dp_ns_C(_dp_prepare_ns):
    _dp_class_annotations = _dp_prepare_ns.get("__annotations__")
    _dp_tmp_2 = __dp__.is_(_dp_class_annotations, None)
    if _dp_tmp_2:
        _dp_class_annotations = __dp__.dict()

    def _dp_var_m_1(self):
        return 1
    return __dp__.list((("__module__", __name__), ("__qualname__", "C"), ("m", _dp_var_m_1)))
def _dp_make_class_C():
    orig_bases = ()
    bases = __dp__.resolve_bases(orig_bases)
    _dp_tmp_3 = __dp__.prepare_class("C", bases, None)
    meta = __dp__.getitem(_dp_tmp_3, 0)
    ns = __dp__.getitem(_dp_tmp_3, 1)
    kwds = __dp__.getitem(_dp_tmp_3, 2)
    _dp_namespace_entries = _dp_ns_C(ns)
    _dp_temp_ns = __dp__.dict()
    _dp_iter_4 = __dp__.iter(_dp_namespace_entries)
    while True:
        try:
            _dp_tmp_5 = __dp__.next(_dp_iter_4)
            _dp_name = __dp__.getitem(_dp_tmp_5, 0)
            _dp_value = __dp__.getitem(_dp_tmp_5, 1)
        except:
            __dp__.check_stopiteration()
            break
        else:
            __dp__.setitem(_dp_temp_ns, _dp_name, _dp_value)
            __dp__.setitem(ns, _dp_name, _dp_value)
    _dp_tmp_7 = __dp__.is_not(orig_bases, bases)
    _dp_tmp_6 = _dp_tmp_7
    if _dp_tmp_6:
        _dp_tmp_8 = __dp__.not_(__dp__.contains(ns, "__orig_bases__"))
        _dp_tmp_6 = _dp_tmp_8
    if _dp_tmp_6:
        __dp__.setitem(ns, "__orig_bases__", orig_bases)
    return meta("C", bases, ns, **kwds)
_dp_class_C = _dp_make_class_C()
C = _dp_class_C
$ rewrites super and class

class C:
    def m(self):
        return super().m()
=
def _dp_ns_C(_dp_prepare_ns):
    _dp_class_annotations = _dp_prepare_ns.get("__annotations__")
    _dp_tmp_2 = __dp__.is_(_dp_class_annotations, None)
    if _dp_tmp_2:
        _dp_class_annotations = __dp__.dict()

    def _dp_var_m_1(self):
        return super(C, self).m()
    return __dp__.list((("__module__", __name__), ("__qualname__", "C"), ("m", _dp_var_m_1)))
def _dp_make_class_C():
    orig_bases = ()
    bases = __dp__.resolve_bases(orig_bases)
    _dp_tmp_3 = __dp__.prepare_class("C", bases, None)
    meta = __dp__.getitem(_dp_tmp_3, 0)
    ns = __dp__.getitem(_dp_tmp_3, 1)
    kwds = __dp__.getitem(_dp_tmp_3, 2)
    _dp_namespace_entries = _dp_ns_C(ns)
    _dp_temp_ns = __dp__.dict()
    _dp_iter_4 = __dp__.iter(_dp_namespace_entries)
    while True:
        try:
            _dp_tmp_5 = __dp__.next(_dp_iter_4)
            _dp_name = __dp__.getitem(_dp_tmp_5, 0)
            _dp_value = __dp__.getitem(_dp_tmp_5, 1)
        except:
            __dp__.check_stopiteration()
            break
        else:
            __dp__.setitem(_dp_temp_ns, _dp_name, _dp_value)
            __dp__.setitem(ns, _dp_name, _dp_value)
    _dp_tmp_7 = __dp__.is_not(orig_bases, bases)
    _dp_tmp_6 = _dp_tmp_7
    if _dp_tmp_6:
        _dp_tmp_8 = __dp__.not_(__dp__.contains(ns, "__orig_bases__"))
        _dp_tmp_6 = _dp_tmp_8
    if _dp_tmp_6:
        __dp__.setitem(ns, "__orig_bases__", orig_bases)
    return meta("C", bases, ns, **kwds)
_dp_class_C = _dp_make_class_C()
C = _dp_class_C
$ rewrites super uses first arg

class C:
    def m(z):
        return super().m()
=
def _dp_ns_C(_dp_prepare_ns):
    _dp_class_annotations = _dp_prepare_ns.get("__annotations__")
    _dp_tmp_2 = __dp__.is_(_dp_class_annotations, None)
    if _dp_tmp_2:
        _dp_class_annotations = __dp__.dict()

    def _dp_var_m_1(z):
        return super(C, z).m()
    return __dp__.list((("__module__", __name__), ("__qualname__", "C"), ("m", _dp_var_m_1)))
def _dp_make_class_C():
    orig_bases = ()
    bases = __dp__.resolve_bases(orig_bases)
    _dp_tmp_3 = __dp__.prepare_class("C", bases, None)
    meta = __dp__.getitem(_dp_tmp_3, 0)
    ns = __dp__.getitem(_dp_tmp_3, 1)
    kwds = __dp__.getitem(_dp_tmp_3, 2)
    _dp_namespace_entries = _dp_ns_C(ns)
    _dp_temp_ns = __dp__.dict()
    _dp_iter_4 = __dp__.iter(_dp_namespace_entries)
    while True:
        try:
            _dp_tmp_5 = __dp__.next(_dp_iter_4)
            _dp_name = __dp__.getitem(_dp_tmp_5, 0)
            _dp_value = __dp__.getitem(_dp_tmp_5, 1)
        except:
            __dp__.check_stopiteration()
            break
        else:
            __dp__.setitem(_dp_temp_ns, _dp_name, _dp_value)
            __dp__.setitem(ns, _dp_name, _dp_value)
    _dp_tmp_7 = __dp__.is_not(orig_bases, bases)
    _dp_tmp_6 = _dp_tmp_7
    if _dp_tmp_6:
        _dp_tmp_8 = __dp__.not_(__dp__.contains(ns, "__orig_bases__"))
        _dp_tmp_6 = _dp_tmp_8
    if _dp_tmp_6:
        __dp__.setitem(ns, "__orig_bases__", orig_bases)
    return meta("C", bases, ns, **kwds)
_dp_class_C = _dp_make_class_C()
C = _dp_class_C
$ rewrites super without receiver

class C:
    def m():
        return super().m()
=
def _dp_ns_C(_dp_prepare_ns):
    _dp_class_annotations = _dp_prepare_ns.get("__annotations__")
    _dp_tmp_2 = __dp__.is_(_dp_class_annotations, None)
    if _dp_tmp_2:
        _dp_class_annotations = __dp__.dict()

    def _dp_var_m_1():
        return super(C, None).m()
    return __dp__.list((("__module__", __name__), ("__qualname__", "C"), ("m", _dp_var_m_1)))
def _dp_make_class_C():
    orig_bases = ()
    bases = __dp__.resolve_bases(orig_bases)
    _dp_tmp_3 = __dp__.prepare_class("C", bases, None)
    meta = __dp__.getitem(_dp_tmp_3, 0)
    ns = __dp__.getitem(_dp_tmp_3, 1)
    kwds = __dp__.getitem(_dp_tmp_3, 2)
    _dp_namespace_entries = _dp_ns_C(ns)
    _dp_temp_ns = __dp__.dict()
    _dp_iter_4 = __dp__.iter(_dp_namespace_entries)
    while True:
        try:
            _dp_tmp_5 = __dp__.next(_dp_iter_4)
            _dp_name = __dp__.getitem(_dp_tmp_5, 0)
            _dp_value = __dp__.getitem(_dp_tmp_5, 1)
        except:
            __dp__.check_stopiteration()
            break
        else:
            __dp__.setitem(_dp_temp_ns, _dp_name, _dp_value)
            __dp__.setitem(ns, _dp_name, _dp_value)
    _dp_tmp_7 = __dp__.is_not(orig_bases, bases)
    _dp_tmp_6 = _dp_tmp_7
    if _dp_tmp_6:
        _dp_tmp_8 = __dp__.not_(__dp__.contains(ns, "__orig_bases__"))
        _dp_tmp_6 = _dp_tmp_8
    if _dp_tmp_6:
        __dp__.setitem(ns, "__orig_bases__", orig_bases)
    return meta("C", bases, ns, **kwds)
_dp_class_C = _dp_make_class_C()
C = _dp_class_C
$ applies decorators in namespace

class C:
    y = deco

    @decorator(y)
    @other
    def m(self):
        return self
=
def _dp_ns_C(_dp_prepare_ns):
    _dp_class_annotations = _dp_prepare_ns.get("__annotations__")
    _dp_tmp_3 = __dp__.is_(_dp_class_annotations, None)
    if _dp_tmp_3:
        _dp_class_annotations = __dp__.dict()
    _dp_var_y_1 = deco
    _dp_decorator__dp_var_m_2_0 = decorator(_dp_var_y_1)
    _dp_decorator__dp_var_m_2_1 = other

    def _dp_var_m_2(self):
        return self
    _dp_var_m_2 = _dp_decorator__dp_var_m_2_0(_dp_decorator__dp_var_m_2_1(_dp_var_m_2))
    return __dp__.list((("__module__", __name__), ("__qualname__", "C"), ("y", _dp_var_y_1), ("m", _dp_var_m_2)))
def _dp_make_class_C():
    orig_bases = ()
    bases = __dp__.resolve_bases(orig_bases)
    _dp_tmp_4 = __dp__.prepare_class("C", bases, None)
    meta = __dp__.getitem(_dp_tmp_4, 0)
    ns = __dp__.getitem(_dp_tmp_4, 1)
    kwds = __dp__.getitem(_dp_tmp_4, 2)
    _dp_namespace_entries = _dp_ns_C(ns)
    _dp_temp_ns = __dp__.dict()
    _dp_iter_5 = __dp__.iter(_dp_namespace_entries)
    while True:
        try:
            _dp_tmp_6 = __dp__.next(_dp_iter_5)
            _dp_name = __dp__.getitem(_dp_tmp_6, 0)
            _dp_value = __dp__.getitem(_dp_tmp_6, 1)
        except:
            __dp__.check_stopiteration()
            break
        else:
            __dp__.setitem(_dp_temp_ns, _dp_name, _dp_value)
            __dp__.setitem(ns, _dp_name, _dp_value)
    _dp_tmp_8 = __dp__.is_not(orig_bases, bases)
    _dp_tmp_7 = _dp_tmp_8
    if _dp_tmp_7:
        _dp_tmp_9 = __dp__.not_(__dp__.contains(ns, "__orig_bases__"))
        _dp_tmp_7 = _dp_tmp_9
    if _dp_tmp_7:
        __dp__.setitem(ns, "__orig_bases__", orig_bases)
    return meta("C", bases, ns, **kwds)
_dp_class_C = _dp_make_class_C()
C = _dp_class_C
$ renames class stores and uses

class C:
    a = 1
    b = a

    def f(self, value: b = a):
        return value
=
def _dp_ns_C(_dp_prepare_ns):
    _dp_class_annotations = _dp_prepare_ns.get("__annotations__")
    _dp_tmp_4 = __dp__.is_(_dp_class_annotations, None)
    if _dp_tmp_4:
        _dp_class_annotations = __dp__.dict()
    _dp_var_a_1 = 1
    _dp_var_b_2 = _dp_var_a_1

    def _dp_var_f_3(self, value: _dp_var_b_2=_dp_var_a_1):
        return value
    return __dp__.list((("__module__", __name__), ("__qualname__", "C"), ("a", _dp_var_a_1), ("b", _dp_var_b_2), ("f", _dp_var_f_3)))
def _dp_make_class_C():
    orig_bases = ()
    bases = __dp__.resolve_bases(orig_bases)
    _dp_tmp_5 = __dp__.prepare_class("C", bases, None)
    meta = __dp__.getitem(_dp_tmp_5, 0)
    ns = __dp__.getitem(_dp_tmp_5, 1)
    kwds = __dp__.getitem(_dp_tmp_5, 2)
    _dp_namespace_entries = _dp_ns_C(ns)
    _dp_temp_ns = __dp__.dict()
    _dp_iter_6 = __dp__.iter(_dp_namespace_entries)
    while True:
        try:
            _dp_tmp_7 = __dp__.next(_dp_iter_6)
            _dp_name = __dp__.getitem(_dp_tmp_7, 0)
            _dp_value = __dp__.getitem(_dp_tmp_7, 1)
        except:
            __dp__.check_stopiteration()
            break
        else:
            __dp__.setitem(_dp_temp_ns, _dp_name, _dp_value)
            __dp__.setitem(ns, _dp_name, _dp_value)
    _dp_tmp_9 = __dp__.is_not(orig_bases, bases)
    _dp_tmp_8 = _dp_tmp_9
    if _dp_tmp_8:
        _dp_tmp_10 = __dp__.not_(__dp__.contains(ns, "__orig_bases__"))
        _dp_tmp_8 = _dp_tmp_10
    if _dp_tmp_8:
        __dp__.setitem(ns, "__orig_bases__", orig_bases)
    return meta("C", bases, ns, **kwds)
_dp_class_C = _dp_make_class_C()
C = _dp_class_C
