$ rewrites function decorators

@dec2(5)
@dec1
def foo():
    pass
=
_dp_decorator_foo_0 = dec2(5)
_dp_decorator_foo_1 = dec1
def foo():
    pass
foo = _dp_decorator_foo_0(_dp_decorator_foo_1(foo))
$ preserves annotations on decorated functions

@dec
def foo(x: int) -> str:
    pass
=
_dp_decorator_foo_0 = dec
def foo(x: int) -> str:
    pass
foo = _dp_decorator_foo_0(foo)
$ rewrites class decorators

@dec
class C:
    pass
=
_dp_decorator_C_0 = dec
def _dp_ns_C(_dp_prepare_ns, _dp_add_binding):
    _dp_add_binding("__module__", __name__)
    _dp_add_binding("__qualname__", "C")
    _dp_class_annotations = _dp_prepare_ns.get("__annotations__")
    _dp_tmp_1 = __dp__.is_(_dp_class_annotations, None)
    if _dp_tmp_1:
        _dp_class_annotations = __dp__.dict()
def _dp_make_class_C():
    orig_bases = ()
    bases = __dp__.resolve_bases(orig_bases)
    _dp_tmp_2 = __dp__.prepare_class("C", bases, None)
    meta = __dp__.getitem(_dp_tmp_2, 0)
    ns = __dp__.getitem(_dp_tmp_2, 1)
    kwds = __dp__.getitem(_dp_tmp_2, 2)
    _dp_temp_ns = __dp__.dict()

    def _dp_add_binding(name: str, value):
        __dp__.setitem(_dp_temp_ns, name, value)
        __dp__.setitem(ns, name, value)
        return value
    _dp_ns_C(ns, _dp_add_binding)
    _dp_tmp_4 = __dp__.is_not(orig_bases, bases)
    _dp_tmp_3 = _dp_tmp_4
    if _dp_tmp_3:
        _dp_tmp_5 = __dp__.not_(__dp__.contains(ns, "__orig_bases__"))
        _dp_tmp_3 = _dp_tmp_5
    if _dp_tmp_3:
        __dp__.setitem(ns, "__orig_bases__", orig_bases)
    return meta("C", bases, ns, **kwds)
_dp_class_C = _dp_make_class_C()
C = _dp_class_C
C = _dp_decorator_C_0(C)
$ rewrites multiple class decorators

@dec2(5)
@dec1
class C:
    pass
=
_dp_decorator_C_0 = dec2(5)
_dp_decorator_C_1 = dec1
def _dp_ns_C(_dp_prepare_ns, _dp_add_binding):
    _dp_add_binding("__module__", __name__)
    _dp_add_binding("__qualname__", "C")
    _dp_class_annotations = _dp_prepare_ns.get("__annotations__")
    _dp_tmp_1 = __dp__.is_(_dp_class_annotations, None)
    if _dp_tmp_1:
        _dp_class_annotations = __dp__.dict()
def _dp_make_class_C():
    orig_bases = ()
    bases = __dp__.resolve_bases(orig_bases)
    _dp_tmp_2 = __dp__.prepare_class("C", bases, None)
    meta = __dp__.getitem(_dp_tmp_2, 0)
    ns = __dp__.getitem(_dp_tmp_2, 1)
    kwds = __dp__.getitem(_dp_tmp_2, 2)
    _dp_temp_ns = __dp__.dict()

    def _dp_add_binding(name: str, value):
        __dp__.setitem(_dp_temp_ns, name, value)
        __dp__.setitem(ns, name, value)
        return value
    _dp_ns_C(ns, _dp_add_binding)
    _dp_tmp_4 = __dp__.is_not(orig_bases, bases)
    _dp_tmp_3 = _dp_tmp_4
    if _dp_tmp_3:
        _dp_tmp_5 = __dp__.not_(__dp__.contains(ns, "__orig_bases__"))
        _dp_tmp_3 = _dp_tmp_5
    if _dp_tmp_3:
        __dp__.setitem(ns, "__orig_bases__", orig_bases)
    return meta("C", bases, ns, **kwds)
_dp_class_C = _dp_make_class_C()
C = _dp_class_C
C = _dp_decorator_C_0(_dp_decorator_C_1(C))
$ preserves existing decorator targets

atexit = property(lambda: None)

@atexit.setter
def atexit(value):
    pass
=
def _dp_lambda_1():
    return None
atexit = property(_dp_lambda_1)
_dp_decorator_atexit_0 = atexit.setter
def atexit(value):
    pass
atexit = _dp_decorator_atexit_0(atexit)
