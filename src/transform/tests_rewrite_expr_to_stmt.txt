$ rewrites bool and assignment

x = a and b
=
_dp_tmp_1 = a
if _dp_tmp_1:
    _dp_tmp_1 = b
x = _dp_tmp_1

$ skips non bool assignment

x = value
=
x = value

$ rewrites bool expr statement

a and b
=
_dp_tmp_1 = a
if _dp_tmp_1:
    _dp_tmp_1 = b
_dp_tmp_1

$ rewrites simple compare assignment

x = a == b
=
_dp_tmp_1 = __dp__.eq(a, b)
x = _dp_tmp_1

$ rewrites chained compare assignment

x = a < b < c
=
_dp_compare_2 = b
_dp_tmp_1 = __dp__.lt(a, _dp_compare_2)
if _dp_tmp_1:
    _dp_tmp_1 = __dp__.lt(_dp_compare_2, c)
x = _dp_tmp_1

$ rewrites multi chained compare assignment

x = a < b <= c < d
=
_dp_compare_2 = b
_dp_tmp_1 = __dp__.lt(a, _dp_compare_2)
if _dp_tmp_1:
    _dp_compare_3 = c
    _dp_tmp_1 = __dp__.le(_dp_compare_2, _dp_compare_3)
if _dp_tmp_1:
    _dp_tmp_1 = __dp__.lt(_dp_compare_3, d)
x = _dp_tmp_1

$ rewrites lambda in return stmt

return lambda: 1
=
def _dp_lambda_1():
    return 1
_dp_lambda_1.__qualname__ = "_dp_lambda_1"
_dp_lambda_1.__code__ = _dp_lambda_1.__code__.replace(co_qualname="_dp_lambda_1")
_dp_lambda_1.__name__ = "<lambda>"
_dp_lambda_1.__qualname__ = "<lambda>"
return _dp_lambda_1

$ rewrites lambda assignment

x = lambda: 1
=
def _dp_lambda_1():
    return 1
_dp_lambda_1.__qualname__ = "_dp_lambda_1"
_dp_lambda_1.__code__ = _dp_lambda_1.__code__.replace(co_qualname="_dp_lambda_1")
_dp_lambda_1.__name__ = "<lambda>"
_dp_lambda_1.__qualname__ = "<lambda>"
x = _dp_lambda_1

$ rewrites generator assignment

x = (i for i in items)
=
def _dp_gen_1(_dp_iter_2):
    _dp_iter_3 = __dp__.iter(_dp_iter_2)
    while True:
        try:
            i = __dp__.next(_dp_iter_3)
        except:
            __dp__.check_stopiteration()
            break
        else:
            yield i
_dp_gen_1.__qualname__ = "_dp_gen_1"
_dp_gen_1.__code__ = _dp_gen_1.__code__.replace(co_qualname="_dp_gen_1")
_dp_gen_1.__name__ = "<genexpr>"
_dp_gen_1.__qualname__ = "<genexpr>"
_dp_gen_1.__code__ = _dp_gen_1.__code__.replace(co_name="<genexpr>", co_qualname="<genexpr>")
x = _dp_gen_1(__dp__.iter(items))

$ rewrites yield from expression

x = yield from y
=
x = yield from y

$ rewrites named expression in boolop

if (y := foo()) and bar:
    pass
=
_dp_tmp_2 = foo()
y = _dp_tmp_2
_dp_tmp_1 = _dp_tmp_2
if _dp_tmp_1:
    _dp_tmp_1 = bar
if _dp_tmp_1:
    pass
