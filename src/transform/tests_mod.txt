$ strips type alias statement

type Alias = int
=


$ preserves float literal precision

VALUE = 0.9999999999999999
=
VALUE = __dp__.float_from_literal("0.9999999999999999")

$ strips type aliases in if branches

if True:
    type Alias = int
    x = 1
elif False:
    type Alias = str
    y = 2
else:
    type Alias = bytes
    z = 3
=
if True:
    x = 1
else:
    if False:
        y = 2
    else:
        z = 3

$ strips type alias from class body

type Alias = int

class Foo:
    type Inner = str

    def method(self):
        return 1
=
def _dp_create_class_Foo():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_1():
            return __name__
        _dp_lambda_1.__name__ = "<lambda>"
        _dp_lambda_1.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_1)
        _dp_class_ns.__qualname__ = "Foo"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_lambda_2():
            return str
        _dp_lambda_2.__name__ = "<lambda>"
        _dp_lambda_2.__qualname__ = "<lambda>"

        def _dp_fn_method(self):
            return 1
        _dp_class_ns.method = __dp__.update_fn(_dp_fn_method, "Foo", "method")
    return __dp__.create_class("Foo", _dp_ns_builder, (), None)
Foo = _dp_create_class_Foo()

$ integration: class lookup lambda avoids recursion

class Example:
    value = __name__

RESULT = Example.value
=
def _dp_create_class_Example():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_1():
            return __name__
        _dp_lambda_1.__name__ = "<lambda>"
        _dp_lambda_1.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_1)
        _dp_class_ns.__qualname__ = "Example"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_lambda_2():
            return __name__
        _dp_lambda_2.__name__ = "<lambda>"
        _dp_lambda_2.__qualname__ = "<lambda>"
        _dp_class_ns.value = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_2)
    return __dp__.create_class("Example", _dp_ns_builder, (), None)
Example = _dp_create_class_Example()
RESULT = Example.value

$ class method name does not shadow module

import time

class Base:
    def __init__(self):
        self.resolution = time.get_clock_info("monotonic").resolution

    def time(self):
        return time.monotonic()

VALUE = Base().resolution
=
time = __dp__.import_("time", __spec__)
def _dp_create_class_Base():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_1():
            return __name__
        _dp_lambda_1.__name__ = "<lambda>"
        _dp_lambda_1.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_1)
        _dp_class_ns.__qualname__ = "Base"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_fn___init__(self):
            self.resolution = time.get_clock_info("monotonic").resolution
        _dp_class_ns.__init__ = __dp__.update_fn(_dp_fn___init__, "Base", "__init__")

        def _dp_fn_time(self):
            return __dp__.global_(globals(), "time").monotonic()
        _dp_class_ns.time = __dp__.update_fn(_dp_fn_time, "Base", "time")
    return __dp__.create_class("Base", _dp_ns_builder, (), None)
Base = _dp_create_class_Base()
VALUE = Base().resolution

$ class method import does not shadow class locals

class Example:
    atexit = "class"

    def __init__(self):
        import atexit
        self.module_name = atexit.__name__

VALUE = Example().module_name
CLASS_ATTR = Example.atexit
=
def _dp_create_class_Example():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_1():
            return __name__
        _dp_lambda_1.__name__ = "<lambda>"
        _dp_lambda_1.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_1)
        _dp_class_ns.__qualname__ = "Example"
        _dp_class_ns.__annotations__ = __dp__.dict()
        _dp_class_ns.atexit = "class"

        def _dp_fn___init__(self):
            atexit = __dp__.import_("atexit", __spec__)
            self.module_name = atexit.__name__
        _dp_class_ns.__init__ = __dp__.update_fn(_dp_fn___init__, "Example", "__init__")
    return __dp__.create_class("Example", _dp_ns_builder, (), None)
Example = _dp_create_class_Example()
VALUE = Example().module_name
CLASS_ATTR = Example.atexit

$ super uses defining class even if name is rebound

class Base:
    def __init__(self):
        self.value = "base"

class Derived(Base):
    def __init__(self):
        super().__init__()
        self.child = True

Alias = Derived
Derived = dict

INSTANCE = Alias()
VALUE = INSTANCE.value
=
def _dp_create_class_Base():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_1():
            return __name__
        _dp_lambda_1.__name__ = "<lambda>"
        _dp_lambda_1.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_1)
        _dp_class_ns.__qualname__ = "Base"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_fn___init__(self):
            self.value = "base"
        _dp_class_ns.__init__ = __dp__.update_fn(_dp_fn___init__, "Base", "__init__")
    return __dp__.create_class("Base", _dp_ns_builder, (), None)
Base = _dp_create_class_Base()
def _dp_create_class_Derived():

    def _dp_ns_builder(_dp_class_ns):
        __class__ = __dp__.make_classcell()
        _dp_class_ns.__classcell__ = __class__

        def _dp_lambda_2():
            return __name__
        _dp_lambda_2.__name__ = "<lambda>"
        _dp_lambda_2.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_2)
        _dp_class_ns.__qualname__ = "Derived"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_fn___init__(self):
            __dp__.super_(__class__, self).__init__()
            self.child = True
        _dp_class_ns.__init__ = __dp__.update_fn(_dp_fn___init__, "Derived", "__init__")
    return __dp__.create_class("Derived", _dp_ns_builder, (Base,), None)
Derived = _dp_create_class_Derived()
Alias = Derived
Derived = dict
INSTANCE = Alias()
VALUE = INSTANCE.value

$ async future traceback includes await line

import asyncio
import traceback

async def raise_exc():
    raise TypeError(42)

async def run():
    fut = asyncio.create_task(raise_exc())
    for _ in range(1):
        try:
            await fut
        except TypeError as exc:
            tb = "".join(traceback.format_tb(exc.__traceback__))
            return tb.count("await fut")
    return -1

COUNT = asyncio.run(run())
=
asyncio = __dp__.import_("asyncio", __spec__)
traceback = __dp__.import_("traceback", __spec__)
async def _dp_fn_raise_exc():
    raise TypeError(42)
raise_exc = __dp__.update_fn(_dp_fn_raise_exc, None, "raise_exc")
async def _dp_fn_run():
    fut = asyncio.create_task(raise_exc())
    _dp_iter_1 = __dp__.iter(range(1))
    while True:
        try:
            _ = __dp__.next(_dp_iter_1)
        except:
            __dp__.check_stopiteration()
            break
        else:
            try:
                await fut
            except:
                if __dp__.exception_matches(__dp__.current_exception(), TypeError):
                    exc = __dp__.current_exception()
                    try:
                        tb = "".join(traceback.format_tb(exc.__traceback__))
                        return tb.count("await fut")
                    finally:
                        try:
                            del exc
                        except:
                            if __dp__.exception_matches(__dp__.current_exception(), NameError):
                                pass
                            else:
                                raise
                else:
                    raise
    return __dp__.neg(1)
run = __dp__.update_fn(_dp_fn_run, None, "run")
COUNT = asyncio.run(run())

$ nested class method name does not shadow outer method

import time

class Outer:
    def format_help(self):
        return "outer"

    class Inner:
        def format_help(self):
            return time.get_clock_info("monotonic").resolution

VALUE = Outer.Inner().format_help()
=
time = __dp__.import_("time", __spec__)
def _dp_create_class_Outer():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_2():
            return __name__
        _dp_lambda_2.__name__ = "<lambda>"
        _dp_lambda_2.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_2)
        _dp_class_ns.__qualname__ = "Outer"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_fn_format_help(self):
            return "outer"
        _dp_class_ns.format_help = __dp__.update_fn(_dp_fn_format_help, "Outer", "format_help")

        def _dp_create_class_Outer_Inner():

            def _dp_ns_builder(_dp_class_ns):

                def _dp_lambda_1():
                    return __name__
                _dp_lambda_1.__name__ = "<lambda>"
                _dp_lambda_1.__qualname__ = "Outer.<lambda>"
                _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_1)
                _dp_class_ns.__qualname__ = "Outer.Inner"
                _dp_class_ns.__annotations__ = __dp__.dict()

                def _dp_fn_format_help(self):
                    return time.get_clock_info("monotonic").resolution
                _dp_class_ns.format_help = __dp__.update_fn(_dp_fn_format_help, "Outer.Inner", "format_help")
            return __dp__.create_class("Inner", _dp_ns_builder, (), None)
        _dp_class_ns.Inner = _dp_create_class_Outer_Inner()
    return __dp__.create_class("Outer", _dp_ns_builder, (), None)
Outer = _dp_create_class_Outer()
VALUE = Outer.Inner().format_help()

$ asyncio wait_for releases cancelled task locals

import asyncio
import gc
import weakref

class Payload:
    pass

async def hold_ref(ref_holder):
    obj = Payload()
    ref_holder.append(weakref.ref(obj))
    await asyncio.sleep(10)

def leak_check():
    ref_holder = []

    async def runner():
        await asyncio.wait_for(hold_ref(ref_holder), 0.01)

    try:
        asyncio.run(runner())
    except asyncio.TimeoutError:
        pass

    gc.collect()
    return ref_holder[0]()
=
asyncio = __dp__.import_("asyncio", __spec__)
gc = __dp__.import_("gc", __spec__)
weakref = __dp__.import_("weakref", __spec__)
def _dp_create_class_Payload():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_1():
            return __name__
        _dp_lambda_1.__name__ = "<lambda>"
        _dp_lambda_1.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_1)
        _dp_class_ns.__qualname__ = "Payload"
        _dp_class_ns.__annotations__ = __dp__.dict()
    return __dp__.create_class("Payload", _dp_ns_builder, (), None)
Payload = _dp_create_class_Payload()
async def _dp_fn_hold_ref(ref_holder):
    obj = Payload()
    ref_holder.append(weakref.ref(obj))
    await asyncio.sleep(10)
hold_ref = __dp__.update_fn(_dp_fn_hold_ref, None, "hold_ref")
def _dp_fn_leak_check():
    ref_holder = __dp__.list(())

    async def _dp_fn_runner():
        await asyncio.wait_for(hold_ref(ref_holder), 0.01)
    runner = __dp__.update_fn(_dp_fn_runner, "leak_check.<locals>", "runner")
    try:
        asyncio.run(runner())
    except:
        if __dp__.exception_matches(__dp__.current_exception(), asyncio.TimeoutError):
            pass
        else:
            raise
    gc.collect()
    return __dp__.getitem(ref_holder, 0)()
leak_check = __dp__.update_fn(_dp_fn_leak_check, None, "leak_check")

$ asyncio ssl handshake timeout cleanup

import gc
import importlib
import ssl
import sys
import types
import weakref
from pathlib import Path

ROOT = Path(__file__).resolve().parents[2]
CPYTHON_ASYNCIO = ROOT / "cpython" / "Lib" / "asyncio"
PKG_NAME = "dp_asyncio"
if PKG_NAME not in sys.modules:
    package = types.ModuleType(PKG_NAME)
    package.__path__ = [str(CPYTHON_ASYNCIO)]
    sys.modules[PKG_NAME] = package

base_events = importlib.import_module(f"{PKG_NAME}.base_events")
constants = importlib.import_module(f"{PKG_NAME}.constants")
exceptions = importlib.import_module(f"{PKG_NAME}.exceptions")
protocols = importlib.import_module(f"{PKG_NAME}.protocols")
selector_events = importlib.import_module(f"{PKG_NAME}.selector_events")
sslproto = importlib.import_module(f"{PKG_NAME}.sslproto")
tasks = importlib.import_module(f"{PKG_NAME}.tasks")

class DummySock:
    def setblocking(self, flag):
        pass

class DummyTransport:
    def __init__(self):
        self.closed = False

    def _force_close(self, exc):
        self.closed = True

    def get_extra_info(self, name, default=None):
        return default

    def write(self, data):
        pass

    def is_closing(self):
        return self.closed

    def pause_reading(self):
        pass

    def resume_reading(self):
        pass

    def set_write_buffer_limits(self, high=None, low=None):
        pass

class DummyLoop(selector_events.BaseSelectorEventLoop):
    def _make_ssl_transport(
        self,
        rawsock,
        protocol,
        sslcontext,
        waiter=None,
        *,
        server_side=False,
        server_hostname=None,
        extra=None,
        server=None,
        ssl_handshake_timeout=constants.SSL_HANDSHAKE_TIMEOUT,
        ssl_shutdown_timeout=constants.SSL_SHUTDOWN_TIMEOUT,
    ):
        ssl_protocol = sslproto.SSLProtocol(
            self,
            protocol,
            sslcontext,
            waiter,
            server_side,
            server_hostname,
            ssl_handshake_timeout=ssl_handshake_timeout,
            ssl_shutdown_timeout=ssl_shutdown_timeout,
        )
        ssl_protocol.connection_made(DummyTransport())
        return ssl_protocol._app_transport

    def _make_socket_transport(self, sock, protocol, waiter=None, *, extra=None, server=None):
        return DummyTransport()

def leak_check():
    loop = DummyLoop()
    sslctx = ssl.create_default_context()
    ref = weakref.ref(sslctx)
    sock = DummySock()

    async def run():
        await tasks.wait_for(
            loop._create_connection_transport(
                sock,
                protocols.Protocol,
                sslctx,
                "",
                ssl_handshake_timeout=10.0,
            ),
            0.01,
        )

    try:
        loop.run_until_complete(run())
    except BaseException as exc:
        if exc.__class__.__name__ not in ("TimeoutError", "CancelledError"):
            raise
    finally:
        loop.close()

    sslctx = None
    gc.collect()
    return ref()
=
gc = __dp__.import_("gc", __spec__)
importlib = __dp__.import_("importlib", __spec__)
ssl = __dp__.import_("ssl", __spec__)
sys = __dp__.import_("sys", __spec__)
types = __dp__.import_("types", __spec__)
weakref = __dp__.import_("weakref", __spec__)
_dp_import_1 = __dp__.import_("pathlib", __spec__, __dp__.list(("Path",)))
Path = __dp__.import_attr(_dp_import_1, "Path")
del _dp_import_1
ROOT = __dp__.getitem(Path(__file__).resolve().parents, 2)
CPYTHON_ASYNCIO = __dp__.truediv(__dp__.truediv(__dp__.truediv(ROOT, "cpython"), "Lib"), "asyncio")
PKG_NAME = "dp_asyncio"
_dp_tmp_2 = __dp__.not_(__dp__.contains(sys.modules, PKG_NAME))
if _dp_tmp_2:
    package = types.ModuleType(PKG_NAME)
    package.__path__ = __dp__.list((str(CPYTHON_ASYNCIO),))
    __dp__.setitem(sys.modules, PKG_NAME, package)
base_events = importlib.import_module("".join((__dp__.builtins.format(PKG_NAME), ".base_events")))
constants = importlib.import_module("".join((__dp__.builtins.format(PKG_NAME), ".constants")))
exceptions = importlib.import_module("".join((__dp__.builtins.format(PKG_NAME), ".exceptions")))
protocols = importlib.import_module("".join((__dp__.builtins.format(PKG_NAME), ".protocols")))
selector_events = importlib.import_module("".join((__dp__.builtins.format(PKG_NAME), ".selector_events")))
sslproto = importlib.import_module("".join((__dp__.builtins.format(PKG_NAME), ".sslproto")))
tasks = importlib.import_module("".join((__dp__.builtins.format(PKG_NAME), ".tasks")))
def _dp_create_class_DummySock():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_3():
            return __name__
        _dp_lambda_3.__name__ = "<lambda>"
        _dp_lambda_3.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_3)
        _dp_class_ns.__qualname__ = "DummySock"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_fn_setblocking(self, flag):
            pass
        _dp_class_ns.setblocking = __dp__.update_fn(_dp_fn_setblocking, "DummySock", "setblocking")
    return __dp__.create_class("DummySock", _dp_ns_builder, (), None)
DummySock = _dp_create_class_DummySock()
def _dp_create_class_DummyTransport():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_4():
            return __name__
        _dp_lambda_4.__name__ = "<lambda>"
        _dp_lambda_4.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_4)
        _dp_class_ns.__qualname__ = "DummyTransport"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_fn___init__(self):
            self.closed = False
        _dp_class_ns.__init__ = __dp__.update_fn(_dp_fn___init__, "DummyTransport", "__init__")

        def _dp_fn__force_close(self, exc):
            self.closed = True
        _dp_class_ns._force_close = __dp__.update_fn(_dp_fn__force_close, "DummyTransport", "_force_close")

        def _dp_fn_get_extra_info(self, name, default=None):
            return default
        _dp_class_ns.get_extra_info = __dp__.update_fn(_dp_fn_get_extra_info, "DummyTransport", "get_extra_info")

        def _dp_fn_write(self, data):
            pass
        _dp_class_ns.write = __dp__.update_fn(_dp_fn_write, "DummyTransport", "write")

        def _dp_fn_is_closing(self):
            return self.closed
        _dp_class_ns.is_closing = __dp__.update_fn(_dp_fn_is_closing, "DummyTransport", "is_closing")

        def _dp_fn_pause_reading(self):
            pass
        _dp_class_ns.pause_reading = __dp__.update_fn(_dp_fn_pause_reading, "DummyTransport", "pause_reading")

        def _dp_fn_resume_reading(self):
            pass
        _dp_class_ns.resume_reading = __dp__.update_fn(_dp_fn_resume_reading, "DummyTransport", "resume_reading")

        def _dp_fn_set_write_buffer_limits(self, high=None, low=None):
            pass
        _dp_class_ns.set_write_buffer_limits = __dp__.update_fn(_dp_fn_set_write_buffer_limits, "DummyTransport", "set_write_buffer_limits")
    return __dp__.create_class("DummyTransport", _dp_ns_builder, (), None)
DummyTransport = _dp_create_class_DummyTransport()
def _dp_create_class_DummyLoop():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_5():
            return __name__
        _dp_lambda_5.__name__ = "<lambda>"
        _dp_lambda_5.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_5)
        _dp_class_ns.__qualname__ = "DummyLoop"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_lambda_6():
            return constants
        _dp_lambda_6.__name__ = "<lambda>"
        _dp_lambda_6.__qualname__ = "<lambda>"

        def _dp_lambda_7():
            return constants
        _dp_lambda_7.__name__ = "<lambda>"
        _dp_lambda_7.__qualname__ = "<lambda>"

        def _dp_fn__make_ssl_transport(self, rawsock, protocol, sslcontext, waiter=None, *, server_side=False, server_hostname=None, extra=None, server=None, ssl_handshake_timeout=__dp__.class_lookup("constants", _dp_class_ns, _dp_lambda_6).SSL_HANDSHAKE_TIMEOUT, ssl_shutdown_timeout=__dp__.class_lookup("constants", _dp_class_ns, _dp_lambda_7).SSL_SHUTDOWN_TIMEOUT):
            ssl_protocol = sslproto.SSLProtocol(self, protocol, sslcontext, waiter, server_side, server_hostname, ssl_handshake_timeout=ssl_handshake_timeout, ssl_shutdown_timeout=ssl_shutdown_timeout)
            ssl_protocol.connection_made(DummyTransport())
            return ssl_protocol._app_transport
        _dp_class_ns._make_ssl_transport = __dp__.update_fn(_dp_fn__make_ssl_transport, "DummyLoop", "_make_ssl_transport")

        def _dp_fn__make_socket_transport(self, sock, protocol, waiter=None, *, extra=None, server=None):
            return DummyTransport()
        _dp_class_ns._make_socket_transport = __dp__.update_fn(_dp_fn__make_socket_transport, "DummyLoop", "_make_socket_transport")
    return __dp__.create_class("DummyLoop", _dp_ns_builder, (selector_events.BaseSelectorEventLoop,), None)
DummyLoop = _dp_create_class_DummyLoop()
def _dp_fn_leak_check():
    loop = DummyLoop()
    sslctx = ssl.create_default_context()
    ref = weakref.ref(sslctx)
    sock = DummySock()

    async def _dp_fn_run():
        await tasks.wait_for(loop._create_connection_transport(sock, protocols.Protocol, sslctx, "", ssl_handshake_timeout=10.0), 0.01)
    run = __dp__.update_fn(_dp_fn_run, "leak_check.<locals>", "run")
    try:
        loop.run_until_complete(run())
    except:
        if __dp__.exception_matches(__dp__.current_exception(), BaseException):
            exc = __dp__.current_exception()
            try:
                _dp_tmp_8 = __dp__.not_(__dp__.contains(("TimeoutError", "CancelledError"), exc.__class__.__name__))
                if _dp_tmp_8:
                    raise
            finally:
                try:
                    del exc
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError):
                        pass
                    else:
                        raise
        else:
            raise
    finally:
        loop.close()
    sslctx = None
    gc.collect()
    return ref()
leak_check = __dp__.update_fn(_dp_fn_leak_check, None, "leak_check")

$ except star preserves exception groups


def handle():
    exc = None
    try:
        raise ExceptionGroup("eg", [OSError("boom")])
    except* OSError as excs:
        exc = excs
    return exc
=
def _dp_fn_handle():
    exc = None
    try:
        raise ExceptionGroup("eg", __dp__.list((OSError("boom"),)))
    except* OSError as excs:
        exc = excs
    return exc
handle = __dp__.update_fn(_dp_fn_handle, None, "handle")

$ except as clears exception binding


import gc
import types

def capture():
    try:
        raise OSError("boom")
    except OSError as err:
        return err

def count_exception_referrer_frames():
    exc = capture()
    refs = [ref for ref in gc.get_referrers(exc) if isinstance(ref, types.FrameType)]
    return len(refs)
=
gc = __dp__.import_("gc", __spec__)
types = __dp__.import_("types", __spec__)
def _dp_fn_capture():
    try:
        raise OSError("boom")
    except:
        if __dp__.exception_matches(__dp__.current_exception(), OSError):
            err = __dp__.current_exception()
            try:
                return err
            finally:
                try:
                    del err
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError):
                        pass
                    else:
                        raise
        else:
            raise
capture = __dp__.update_fn(_dp_fn_capture, None, "capture")
def _dp_fn_count_exception_referrer_frames():
    exc = capture()

    def _dp_gen_1(_dp_iter_2):
        _dp_iter_3 = __dp__.iter(_dp_iter_2)
        while True:
            try:
                ref = __dp__.next(_dp_iter_3)
            except:
                __dp__.check_stopiteration()
                break
            else:
                if isinstance(ref, types.FrameType):
                    yield ref
    _dp_gen_1.__name__ = "<genexpr>"
    _dp_gen_1.__code__ = _dp_gen_1.__code__.replace(co_name="<genexpr>")
    _dp_gen_1 = __dp__.update_fn(_dp_gen_1, "count_exception_referrer_frames.<locals>", "<genexpr>")
    refs = __dp__.list(_dp_gen_1(__dp__.iter(gc.get_referrers(exc))))
    return len(refs)
count_exception_referrer_frames = __dp__.update_fn(_dp_fn_count_exception_referrer_frames, None, "count_exception_referrer_frames")

$ lru cache method pickles with stable qualname


import functools
import pickle

class HasCache:
    @functools.lru_cache()
    def cached_meth(self, x, y):
        return x + y

def pickle_cached_method():
    return pickle.loads(pickle.dumps(HasCache.cached_meth))
=
functools = __dp__.import_("functools", __spec__)
pickle = __dp__.import_("pickle", __spec__)
def _dp_create_class_HasCache():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_2():
            return __name__
        _dp_lambda_2.__name__ = "<lambda>"
        _dp_lambda_2.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_2)
        _dp_class_ns.__qualname__ = "HasCache"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_lambda_3():
            return functools
        _dp_lambda_3.__name__ = "<lambda>"
        _dp_lambda_3.__qualname__ = "<lambda>"
        _dp_tmp_1 = __dp__.class_lookup("functools", _dp_class_ns, _dp_lambda_3).lru_cache()

        def _dp_fn_cached_meth(self, x, y):
            return __dp__.add(x, y)
        _dp_class_ns.cached_meth = _dp_tmp_1(__dp__.update_fn(_dp_fn_cached_meth, "HasCache", "cached_meth"))
    return __dp__.create_class("HasCache", _dp_ns_builder, (), None)
HasCache = _dp_create_class_HasCache()
def _dp_fn_pickle_cached_method():
    return pickle.loads(pickle.dumps(HasCache.cached_meth))
pickle_cached_method = __dp__.update_fn(_dp_fn_pickle_cached_method, None, "pickle_cached_method")

$ positional-only param shadows class attribute


def make_value():
    class Example:
        a = 40

        def compute(self):
            def f(a, b, /):
                return a + b

            return f(1, 2)

    return Example().compute()
=
def _dp_fn_make_value():

    def _dp_create_class_make_value__locals__Example():

        def _dp_ns_builder(_dp_class_ns):

            def _dp_lambda_1():
                return __name__
            _dp_lambda_1.__name__ = "<lambda>"
            _dp_lambda_1.__qualname__ = "make_value.<locals>.<lambda>"
            _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_1)
            _dp_class_ns.__qualname__ = "make_value.<locals>.Example"
            _dp_class_ns.__annotations__ = __dp__.dict()
            _dp_class_ns.a = 40

            def _dp_fn_compute(self):

                def _dp_fn_f(a, b, /):
                    return __dp__.add(a, b)
                f = __dp__.update_fn(_dp_fn_f, "make_value.<locals>.Example.compute.<locals>", "f")
                return f(1, 2)
            _dp_class_ns.compute = __dp__.update_fn(_dp_fn_compute, "make_value.<locals>.Example", "compute")
        return __dp__.create_class("Example", _dp_ns_builder, (), None)
    Example = _dp_create_class_make_value__locals__Example()
    return Example().compute()
make_value = __dp__.update_fn(_dp_fn_make_value, None, "make_value")

$ integration: functools singledispatch qualname

from __future__ import annotations

import functools


class Wrapper:
    def make_nested_class(self):
        class A:
            @functools.singledispatchmethod
            def func(self, arg: int) -> str:
                return str(arg)

        return A

    def bad_register_message(self):
        @functools.singledispatch
        def i(arg):
            return "base"

        try:
            @i.register
            def _(arg):
                return "missing annotation"
        except TypeError as exc:
            return str(exc)

        raise AssertionError("expected TypeError")
=
functools = __dp__.import_("functools", __spec__)
def _dp_create_class_Wrapper():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_6():
            return __name__
        _dp_lambda_6.__name__ = "<lambda>"
        _dp_lambda_6.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_6)
        _dp_class_ns.__qualname__ = "Wrapper"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_fn_make_nested_class(self):

            def _dp_create_class_Wrapper_make_nested_class__locals__A():

                def _dp_ns_builder(_dp_class_ns):

                    def _dp_lambda_2():
                        return __name__
                    _dp_lambda_2.__name__ = "<lambda>"
                    _dp_lambda_2.__qualname__ = "Wrapper.make_nested_class.<locals>.<lambda>"
                    _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_2)
                    _dp_class_ns.__qualname__ = "Wrapper.make_nested_class.<locals>.A"
                    _dp_class_ns.__annotations__ = __dp__.dict()

                    def _dp_lambda_3():
                        return functools
                    _dp_lambda_3.__name__ = "<lambda>"
                    _dp_lambda_3.__qualname__ = "Wrapper.make_nested_class.<locals>.<lambda>"
                    _dp_tmp_1 = __dp__.class_lookup("functools", _dp_class_ns, _dp_lambda_3).singledispatchmethod

                    def _dp_fn_func(self, arg: "int") -> "str":
                        return str(arg)
                    _dp_class_ns.func = _dp_tmp_1(__dp__.update_fn(_dp_fn_func, "Wrapper.make_nested_class.<locals>.A", "func"))
                return __dp__.create_class("A", _dp_ns_builder, (), None)
            A = _dp_create_class_Wrapper_make_nested_class__locals__A()
            return A
        _dp_class_ns.make_nested_class = __dp__.update_fn(_dp_fn_make_nested_class, "Wrapper", "make_nested_class")

        def _dp_fn_bad_register_message(self):
            _dp_tmp_4 = functools.singledispatch

            def _dp_fn_i(arg):
                return "base"
            i = _dp_tmp_4(__dp__.update_fn(_dp_fn_i, "Wrapper.bad_register_message.<locals>", "i"))
            try:
                _dp_tmp_5 = i.register

                def _dp_fn__(arg):
                    return "missing annotation"
                _ = _dp_tmp_5(__dp__.update_fn(_dp_fn__, "Wrapper.bad_register_message.<locals>", "_"))
            except:
                if __dp__.exception_matches(__dp__.current_exception(), TypeError):
                    exc = __dp__.current_exception()
                    try:
                        return str(exc)
                    finally:
                        try:
                            del exc
                        except:
                            if __dp__.exception_matches(__dp__.current_exception(), NameError):
                                pass
                            else:
                                raise
                else:
                    raise
            raise AssertionError("expected TypeError")
        _dp_class_ns.bad_register_message = __dp__.update_fn(_dp_fn_bad_register_message, "Wrapper", "bad_register_message")
    return __dp__.create_class("Wrapper", _dp_ns_builder, (), None)
Wrapper = _dp_create_class_Wrapper()

$ integration: enum dynamic members via vars update

from __future__ import annotations

from enum import Enum


FOO_DEFINES = {
    "FOO_CAT": "aloof",
    "BAR_DOG": "friendly",
    "FOO_HORSE": "big",
}


class Foo(Enum):
    vars().update({
        k: v
        for k, v in FOO_DEFINES.items()
        if k.startswith("FOO_")
    })

    def upper(self):
        return self.value.upper()
=
_dp_import_1 = __dp__.import_("enum", __spec__, __dp__.list(("Enum",)))
Enum = __dp__.import_attr(_dp_import_1, "Enum")
del _dp_import_1
FOO_DEFINES = __dp__.dict((("FOO_CAT", "aloof"), ("BAR_DOG", "friendly"), ("FOO_HORSE", "big")))
def _dp_create_class_Foo():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_7():
            return __name__
        _dp_lambda_7.__name__ = "<lambda>"
        _dp_lambda_7.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_7)
        _dp_class_ns.__qualname__ = "Foo"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_gen_2(_dp_iter_3):
            _dp_iter_4 = __dp__.iter(_dp_iter_3)
            while True:
                try:
                    _dp_tmp_5 = __dp__.next(_dp_iter_4)
                    _dp_tmp_6 = __dp__.unpack(_dp_tmp_5, (True, True))
                    k = __dp__.getitem(_dp_tmp_6, 0)
                    v = __dp__.getitem(_dp_tmp_6, 1)
                    _dp_tmp_6 = None
                    _dp_tmp_5 = None
                except:
                    __dp__.check_stopiteration()
                    break
                else:
                    if k.startswith("FOO_"):
                        yield k, v
        _dp_gen_2.__name__ = "<genexpr>"
        _dp_gen_2.__code__ = _dp_gen_2.__code__.replace(co_name="<genexpr>")
        _dp_gen_2 = __dp__.update_fn(_dp_gen_2, "Foo", "<genexpr>")

        def _dp_lambda_8():
            return FOO_DEFINES
        _dp_lambda_8.__name__ = "<lambda>"
        _dp_lambda_8.__qualname__ = "<lambda>"
        _dp_class_ns._namespace.update(__dp__.dict(_dp_gen_2(__dp__.iter(__dp__.class_lookup("FOO_DEFINES", _dp_class_ns, _dp_lambda_8).items()))))

        def _dp_fn_upper(self):
            return self.value.upper()
        _dp_class_ns.upper = __dp__.update_fn(_dp_fn_upper, "Foo", "upper")
    return __dp__.create_class("Foo", _dp_ns_builder, (Enum,), None)
Foo = _dp_create_class_Foo()

$ integration: enum ignore dynamic names

from __future__ import annotations

from enum import Enum


class Period(Enum):
    _ignore_ = "Period i"
    Period = vars()
    for i in range(2):
        Period[f"day_{i}"] = i
    OneDay = day_1
=
_dp_import_1 = __dp__.import_("enum", __spec__, __dp__.list(("Enum",)))
Enum = __dp__.import_attr(_dp_import_1, "Enum")
del _dp_import_1
def _dp_create_class_Period():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_3():
            return __name__
        _dp_lambda_3.__name__ = "<lambda>"
        _dp_lambda_3.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_3)
        _dp_class_ns.__qualname__ = "Period"
        _dp_class_ns.__annotations__ = __dp__.dict()
        _dp_class_ns._ignore_ = "Period i"
        _dp_class_ns.Period = _dp_class_ns._namespace

        def _dp_lambda_4():
            return range
        _dp_lambda_4.__name__ = "<lambda>"
        _dp_lambda_4.__qualname__ = "<lambda>"
        _dp_iter_2 = __dp__.iter(__dp__.class_lookup("range", _dp_class_ns, _dp_lambda_4)(2))
        while True:
            try:
                _dp_class_ns.i = __dp__.next(_dp_iter_2)
            except:
                __dp__.check_stopiteration()
                break
            else:

                def _dp_lambda_5():
                    return Period
                _dp_lambda_5.__name__ = "<lambda>"
                _dp_lambda_5.__qualname__ = "<lambda>"

                def _dp_lambda_6():
                    return i
                _dp_lambda_6.__name__ = "<lambda>"
                _dp_lambda_6.__qualname__ = "<lambda>"

                def _dp_lambda_7():
                    return i
                _dp_lambda_7.__name__ = "<lambda>"
                _dp_lambda_7.__qualname__ = "<lambda>"
                __dp__.setitem(__dp__.class_lookup("Period", _dp_class_ns, _dp_lambda_5), "".join(("day_", __dp__.builtins.format(__dp__.class_lookup("i", _dp_class_ns, _dp_lambda_6)))), __dp__.class_lookup("i", _dp_class_ns, _dp_lambda_7))

        def _dp_lambda_8():
            return day_1
        _dp_lambda_8.__name__ = "<lambda>"
        _dp_lambda_8.__qualname__ = "<lambda>"
        _dp_class_ns.OneDay = __dp__.class_lookup("day_1", _dp_class_ns, _dp_lambda_8)
    return __dp__.create_class("Period", _dp_ns_builder, (Enum,), None)
Period = _dp_create_class_Period()

$ integration: enum flag nonmember auto or

from __future__ import annotations

from enum import Flag, auto, nonmember


class Status(Flag):
    A = auto()
    B = auto()
    ALL = nonmember(A | B)


def build_values():
    return Status.A, Status.B, Status.ALL
=
_dp_import_1 = __dp__.import_("enum", __spec__, __dp__.list(("Flag", "auto", "nonmember")))
Flag = __dp__.import_attr(_dp_import_1, "Flag")
auto = __dp__.import_attr(_dp_import_1, "auto")
nonmember = __dp__.import_attr(_dp_import_1, "nonmember")
del _dp_import_1
def _dp_create_class_Status():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_2():
            return __name__
        _dp_lambda_2.__name__ = "<lambda>"
        _dp_lambda_2.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_2)
        _dp_class_ns.__qualname__ = "Status"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_lambda_3():
            return auto
        _dp_lambda_3.__name__ = "<lambda>"
        _dp_lambda_3.__qualname__ = "<lambda>"
        _dp_class_ns.A = __dp__.class_lookup("auto", _dp_class_ns, _dp_lambda_3)()

        def _dp_lambda_4():
            return auto
        _dp_lambda_4.__name__ = "<lambda>"
        _dp_lambda_4.__qualname__ = "<lambda>"
        _dp_class_ns.B = __dp__.class_lookup("auto", _dp_class_ns, _dp_lambda_4)()

        def _dp_lambda_5():
            return nonmember
        _dp_lambda_5.__name__ = "<lambda>"
        _dp_lambda_5.__qualname__ = "<lambda>"

        def _dp_lambda_6():
            return A
        _dp_lambda_6.__name__ = "<lambda>"
        _dp_lambda_6.__qualname__ = "<lambda>"

        def _dp_lambda_7():
            return B
        _dp_lambda_7.__name__ = "<lambda>"
        _dp_lambda_7.__qualname__ = "<lambda>"
        _dp_class_ns.ALL = __dp__.class_lookup("nonmember", _dp_class_ns, _dp_lambda_5)(__dp__.or_(__dp__.class_lookup("A", _dp_class_ns, _dp_lambda_6), __dp__.class_lookup("B", _dp_class_ns, _dp_lambda_7)))
    return __dp__.create_class("Status", _dp_ns_builder, (Flag,), None)
Status = _dp_create_class_Status()
def _dp_fn_build_values():
    return Status.A, Status.B, Status.ALL
build_values = __dp__.update_fn(_dp_fn_build_values, None, "build_values")

$ integration: dynamicclassattribute class scope getter

from __future__ import annotations

from types import DynamicClassAttribute


class Base:
    @DynamicClassAttribute
    def spam(self):
        return 1


class Sub(Base):
    spam = Base.__dict__["spam"]

    @spam.getter
    def spam(self):
        return 2


def get_value():
    return Sub().spam
=
_dp_import_1 = __dp__.import_("types", __spec__, __dp__.list(("DynamicClassAttribute",)))
DynamicClassAttribute = __dp__.import_attr(_dp_import_1, "DynamicClassAttribute")
del _dp_import_1
def _dp_create_class_Base():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_2():
            return __name__
        _dp_lambda_2.__name__ = "<lambda>"
        _dp_lambda_2.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_2)
        _dp_class_ns.__qualname__ = "Base"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_fn_spam(self):
            return 1

        def _dp_lambda_3():
            return DynamicClassAttribute
        _dp_lambda_3.__name__ = "<lambda>"
        _dp_lambda_3.__qualname__ = "<lambda>"
        _dp_class_ns.spam = __dp__.class_lookup("DynamicClassAttribute", _dp_class_ns, _dp_lambda_3)(__dp__.update_fn(_dp_fn_spam, "Base", "spam"))
    return __dp__.create_class("Base", _dp_ns_builder, (), None)
Base = _dp_create_class_Base()
def _dp_create_class_Sub():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_5():
            return __name__
        _dp_lambda_5.__name__ = "<lambda>"
        _dp_lambda_5.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_5)
        _dp_class_ns.__qualname__ = "Sub"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_lambda_6():
            return Base
        _dp_lambda_6.__name__ = "<lambda>"
        _dp_lambda_6.__qualname__ = "<lambda>"
        _dp_class_ns.spam = __dp__.getitem(__dp__.class_lookup("Base", _dp_class_ns, _dp_lambda_6).__dict__, "spam")

        def _dp_lambda_7():
            return spam
        _dp_lambda_7.__name__ = "<lambda>"
        _dp_lambda_7.__qualname__ = "<lambda>"
        _dp_tmp_4 = __dp__.class_lookup("spam", _dp_class_ns, _dp_lambda_7).getter

        def _dp_fn_spam(self):
            return 2
        _dp_class_ns.spam = _dp_tmp_4(__dp__.update_fn(_dp_fn_spam, "Sub", "spam"))
    return __dp__.create_class("Sub", _dp_ns_builder, (Base,), None)
Sub = _dp_create_class_Sub()
def _dp_fn_get_value():
    return Sub().spam
get_value = __dp__.update_fn(_dp_fn_get_value, None, "get_value")

$ integration: asyncgen expression async for

from __future__ import annotations

import asyncio


async def arange(n):
    for i in range(n):
        await asyncio.sleep(0)
        yield i


def make_arange(n):
    return (i * 2 async for i in arange(n))


async def run():
    return [i async for i in make_arange(3)]


def get_values():
    return asyncio.run(run())
=
asyncio = __dp__.import_("asyncio", __spec__)
async def _dp_fn_arange(n):
    _dp_iter_1 = __dp__.iter(range(n))
    while True:
        try:
            i = __dp__.next(_dp_iter_1)
        except:
            __dp__.check_stopiteration()
            break
        else:
            await asyncio.sleep(0)
            yield i
arange = __dp__.update_fn(_dp_fn_arange, None, "arange")
def _dp_fn_make_arange(n):

    async def _dp_gen_2(_dp_iter_3):
        _dp_iter_4 = __dp__.aiter(_dp_iter_3)
        while True:
            try:
                i = await __dp__.anext(_dp_iter_4)
            except:
                __dp__.acheck_stopiteration()
                break
            else:
                yield __dp__.mul(i, 2)
    _dp_gen_2.__name__ = "<genexpr>"
    _dp_gen_2.__code__ = _dp_gen_2.__code__.replace(co_name="<genexpr>")
    _dp_gen_2 = __dp__.update_fn(_dp_gen_2, "make_arange.<locals>", "<genexpr>")
    return _dp_gen_2(arange(n))
make_arange = __dp__.update_fn(_dp_fn_make_arange, None, "make_arange")
async def _dp_fn_run():
    _dp_tmp_5 = __dp__.list(())
    _dp_iter_6 = __dp__.aiter(make_arange(3))
    while True:
        try:
            i = await __dp__.anext(_dp_iter_6)
        except:
            __dp__.acheck_stopiteration()
            break
        else:
            _dp_tmp_5.append(i)
    return _dp_tmp_5
run = __dp__.update_fn(_dp_fn_run, None, "run")
def _dp_fn_get_values():
    return asyncio.run(run())
get_values = __dp__.update_fn(_dp_fn_get_values, None, "get_values")

$ integration: assert shadowing

from __future__ import annotations


def trigger():
    global AssertionError
    AssertionError = TypeError
    try:
        assert False, "hello"
    except BaseException as exc:
        del AssertionError
        return exc
    else:
        del AssertionError
        raise AssertionError("missing exception")
=
def _dp_fn_trigger():
    global AssertionError
    AssertionError = TypeError
    try:
        if __debug__:
            if __dp__.not_(False):
                raise __dp__.builtins.AssertionError("hello")
    except:
        if __dp__.exception_matches(__dp__.current_exception(), BaseException):
            exc = __dp__.current_exception()
            try:
                del AssertionError
                return exc
            finally:
                try:
                    del exc
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError):
                        pass
                    else:
                        raise
        else:
            raise
    else:
        del AssertionError
        raise AssertionError("missing exception")
trigger = __dp__.update_fn(_dp_fn_trigger, None, "trigger")

$ integration: exception cleanup name

from __future__ import annotations


def has_exception_name():
    try:
        1 / 0
    except Exception as e:
        pass
    return "e" in locals()
=
def _dp_fn_has_exception_name():
    try:
        __dp__.truediv(1, 0)
    except:
        if __dp__.exception_matches(__dp__.current_exception(), Exception):
            e = __dp__.current_exception()
            try:
                pass
            finally:
                try:
                    del e
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError):
                        pass
                    else:
                        raise
        else:
            raise
    _dp_tmp_1 = __dp__.contains(locals(), "e")
    return _dp_tmp_1
has_exception_name = __dp__.update_fn(_dp_fn_has_exception_name, None, "has_exception_name")

$ integration: exception cleanup deleted

def cleanup_deleted():
    try:
        raise Exception()
    except Exception as e:
        del e
    return "e" in locals()


def unbound_after_delete():
    try:
        raise Exception()
    except Exception as e:
        del e
    try:
        e
    except UnboundLocalError:
        return True
    return False
=
def _dp_fn_cleanup_deleted():
    try:
        raise Exception()
    except:
        if __dp__.exception_matches(__dp__.current_exception(), Exception):
            e = __dp__.current_exception()
            try:
                del e
            finally:
                try:
                    del e
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError):
                        pass
                    else:
                        raise
        else:
            raise
    _dp_tmp_1 = __dp__.contains(locals(), "e")
    return _dp_tmp_1
cleanup_deleted = __dp__.update_fn(_dp_fn_cleanup_deleted, None, "cleanup_deleted")
def _dp_fn_unbound_after_delete():
    try:
        raise Exception()
    except:
        if __dp__.exception_matches(__dp__.current_exception(), Exception):
            e = __dp__.current_exception()
            try:
                del e
            finally:
                try:
                    del e
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError):
                        pass
                    else:
                        raise
        else:
            raise
    try:
        e
    except:
        if __dp__.exception_matches(__dp__.current_exception(), UnboundLocalError):
            return True
        else:
            raise
    return False
unbound_after_delete = __dp__.update_fn(_dp_fn_unbound_after_delete, None, "unbound_after_delete")

$ integration: fstring debug conversion

def format_debug():
    value = "A string"
    return f"{value=}"
=
def _dp_fn_format_debug():
    value = "A string"
    return "".join(("value=", __dp__.builtins.format(repr(value))))
format_debug = __dp__.update_fn(_dp_fn_format_debug, None, "format_debug")

$ integration: ast visit ellipsis

import ast


def visit_ellipsis():
    log = []

    class Visitor(ast.NodeVisitor):
        def visit_Ellipsis(self, node):
            log.append(("Ellipsis", ...))

    mod = ast.parse("e = ...")
    Visitor().visit(mod)
    return log
=
ast = __dp__.import_("ast", __spec__)
def _dp_fn_visit_ellipsis():
    log = __dp__.list(())

    def _dp_create_class_visit_ellipsis__locals__Visitor():

        def _dp_ns_builder(_dp_class_ns):

            def _dp_lambda_1():
                return __name__
            _dp_lambda_1.__name__ = "<lambda>"
            _dp_lambda_1.__qualname__ = "visit_ellipsis.<locals>.<lambda>"
            _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_1)
            _dp_class_ns.__qualname__ = "visit_ellipsis.<locals>.Visitor"
            _dp_class_ns.__annotations__ = __dp__.dict()

            def _dp_fn_visit_Ellipsis(self, node):
                log.append(("Ellipsis", ...))
            _dp_class_ns.visit_Ellipsis = __dp__.update_fn(_dp_fn_visit_Ellipsis, "visit_ellipsis.<locals>.Visitor", "visit_Ellipsis")
        return __dp__.create_class("Visitor", _dp_ns_builder, (ast.NodeVisitor,), None)
    Visitor = _dp_create_class_visit_ellipsis__locals__Visitor()
    mod = ast.parse("e = ...")
    Visitor().visit(mod)
    return log
visit_ellipsis = __dp__.update_fn(_dp_fn_visit_ellipsis, None, "visit_ellipsis")

$ integration: disable transform temp module

import importlib
import sys
import textwrap
from pathlib import Path


def import_without_transform(tmp_path: Path) -> bool:
    module_name = "dp_disable_temp"
    module_path = tmp_path / f"{module_name}.py"
    module_path.write_text(
        textwrap.dedent(
            """\
            # diet-python: disable
            VALUE = 1
            """
        ),
        encoding="utf-8",
    )
    sys.path.insert(0, str(tmp_path))
    try:
        sys.modules.pop(module_name, None)
        module = importlib.import_module(module_name)
        return "__dp__" in module.__dict__
    finally:
        sys.modules.pop(module_name, None)
        if sys.path and sys.path[0] == str(tmp_path):
            sys.path.pop(0)
=
importlib = __dp__.import_("importlib", __spec__)
sys = __dp__.import_("sys", __spec__)
textwrap = __dp__.import_("textwrap", __spec__)
_dp_import_1 = __dp__.import_("pathlib", __spec__, __dp__.list(("Path",)))
Path = __dp__.import_attr(_dp_import_1, "Path")
del _dp_import_1
def _dp_fn_import_without_transform(tmp_path: Path) -> bool:
    module_name = "dp_disable_temp"
    module_path = __dp__.truediv(tmp_path, "".join((__dp__.builtins.format(module_name), ".py")))
    module_path.write_text(textwrap.dedent("""            # diet-python: disable\n            VALUE = 1\n            """), encoding="utf-8")
    sys.path.insert(0, str(tmp_path))
    try:
        sys.modules.pop(module_name, None)
        module = importlib.import_module(module_name)
        _dp_tmp_2 = __dp__.contains(module.__dict__, "__dp__")
        return _dp_tmp_2
    finally:
        sys.modules.pop(module_name, None)
        _dp_tmp_3 = sys.path
        if _dp_tmp_3:
            _dp_tmp_4 = __dp__.eq(__dp__.getitem(sys.path, 0), str(tmp_path))
            _dp_tmp_3 = _dp_tmp_4
        if _dp_tmp_3:
            sys.path.pop(0)
import_without_transform = __dp__.update_fn(_dp_fn_import_without_transform, None, "import_without_transform")

$ integration: skip outside repo transform

import importlib
import sys
from pathlib import Path


def imported_without_transform(tmp_path: Path) -> bool:
    module_name = "dp_outside_repo"
    module_path = tmp_path / f"{module_name}.py"
    module_path.write_text("VALUE = 1\n", encoding="utf-8")
    sys.path.insert(0, str(tmp_path))
    try:
        sys.modules.pop(module_name, None)
        module = importlib.import_module(module_name)
        return "__dp__" in module.__dict__
    finally:
        sys.modules.pop(module_name, None)
        if sys.path and sys.path[0] == str(tmp_path):
            sys.path.pop(0)
=
importlib = __dp__.import_("importlib", __spec__)
sys = __dp__.import_("sys", __spec__)
_dp_import_1 = __dp__.import_("pathlib", __spec__, __dp__.list(("Path",)))
Path = __dp__.import_attr(_dp_import_1, "Path")
del _dp_import_1
def _dp_fn_imported_without_transform(tmp_path: Path) -> bool:
    module_name = "dp_outside_repo"
    module_path = __dp__.truediv(tmp_path, "".join((__dp__.builtins.format(module_name), ".py")))
    module_path.write_text("VALUE = 1\n", encoding="utf-8")
    sys.path.insert(0, str(tmp_path))
    try:
        sys.modules.pop(module_name, None)
        module = importlib.import_module(module_name)
        _dp_tmp_2 = __dp__.contains(module.__dict__, "__dp__")
        return _dp_tmp_2
    finally:
        sys.modules.pop(module_name, None)
        _dp_tmp_3 = sys.path
        if _dp_tmp_3:
            _dp_tmp_4 = __dp__.eq(__dp__.getitem(sys.path, 0), str(tmp_path))
            _dp_tmp_3 = _dp_tmp_4
        if _dp_tmp_3:
            sys.path.pop(0)
imported_without_transform = __dp__.update_fn(_dp_fn_imported_without_transform, None, "imported_without_transform")

$ integration: strip internal traceback

from pathlib import Path


def traceback_files():
    try:
        import nonexistent_xyzzy
    except ImportError as exc:
        tb = exc.__traceback__
        files = []
        while tb:
            files.append(Path(tb.tb_frame.f_code.co_filename).name)
            tb = tb.tb_next
        return files
    return []
=
_dp_import_1 = __dp__.import_("pathlib", __spec__, __dp__.list(("Path",)))
Path = __dp__.import_attr(_dp_import_1, "Path")
del _dp_import_1
def _dp_fn_traceback_files():
    try:
        nonexistent_xyzzy = __dp__.import_("nonexistent_xyzzy", __spec__)
    except:
        if __dp__.exception_matches(__dp__.current_exception(), ImportError):
            exc = __dp__.current_exception()
            try:
                tb = exc.__traceback__
                files = __dp__.list(())
                while tb:
                    files.append(Path(tb.tb_frame.f_code.co_filename).name)
                    tb = tb.tb_next
                return files
            finally:
                try:
                    del exc
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError):
                        pass
                    else:
                        raise
        else:
            raise
    return __dp__.list(())
traceback_files = __dp__.update_fn(_dp_fn_traceback_files, None, "traceback_files")

$ integration: dotted import alias rebind

import sys
from pathlib import Path


def alias_rebind_attrs(tmp_path: Path) -> tuple[str, str]:
    package_name = "dp_alias_pkg"
    package_dir = tmp_path / package_name
    package_dir.mkdir()
    init_path = package_dir / "__init__.py"
    init_path.write_text("from .submodule import submodule\n", encoding="utf-8")
    submodule_path = package_dir / "submodule.py"
    submodule_path.write_text(
        "attr = 'submodule'\nclass submodule:\n    attr = 'rebound'\n",
        encoding="utf-8",
    )
    sys.path.insert(0, str(tmp_path))
    try:
        sys.modules.pop(package_name, None)
        sys.modules.pop(f"{package_name}.submodule", None)
        from dp_alias_pkg import submodule as from_import
        import dp_alias_pkg.submodule as direct_import
        return from_import.attr, direct_import.attr
    finally:
        sys.modules.pop(package_name, None)
        sys.modules.pop(f"{package_name}.submodule", None)
        if sys.path and sys.path[0] == str(tmp_path):
            sys.path.pop(0)
=
sys = __dp__.import_("sys", __spec__)
_dp_import_1 = __dp__.import_("pathlib", __spec__, __dp__.list(("Path",)))
Path = __dp__.import_attr(_dp_import_1, "Path")
del _dp_import_1
def _dp_fn_alias_rebind_attrs(tmp_path: Path) -> __dp__.getitem(tuple, (str, str)):
    package_name = "dp_alias_pkg"
    package_dir = __dp__.truediv(tmp_path, package_name)
    package_dir.mkdir()
    init_path = __dp__.truediv(package_dir, "__init__.py")
    init_path.write_text("from .submodule import submodule\n", encoding="utf-8")
    submodule_path = __dp__.truediv(package_dir, "submodule.py")
    submodule_path.write_text("attr = 'submodule'\nclass submodule:\n    attr = 'rebound'\n", encoding="utf-8")
    sys.path.insert(0, str(tmp_path))
    try:
        sys.modules.pop(package_name, None)
        sys.modules.pop("".join((__dp__.builtins.format(package_name), ".submodule")), None)
        _dp_import_2 = __dp__.import_("dp_alias_pkg", __spec__, __dp__.list(("submodule",)))
        from_import = __dp__.import_attr(_dp_import_2, "submodule")
        del _dp_import_2
        direct_import = __dp__.import_attr(__dp__.import_("dp_alias_pkg.submodule", __spec__), "submodule")
        return from_import.attr, direct_import.attr
    finally:
        sys.modules.pop(package_name, None)
        sys.modules.pop("".join((__dp__.builtins.format(package_name), ".submodule")), None)
        _dp_tmp_3 = sys.path
        if _dp_tmp_3:
            _dp_tmp_4 = __dp__.eq(__dp__.getitem(sys.path, 0), str(tmp_path))
            _dp_tmp_3 = _dp_tmp_4
        if _dp_tmp_3:
            sys.path.pop(0)
alias_rebind_attrs = __dp__.update_fn(_dp_fn_alias_rebind_attrs, None, "alias_rebind_attrs")

$ integration: meta path pathfinder preserved

import importlib
import sys
import textwrap
from pathlib import Path
from tempfile import TemporaryDirectory

import diet_import_hook


def import_with_filtered_meta_path() -> bool:
    diet_import_hook.install()
    original_meta_path = list(sys.meta_path)
    try:
        sys.meta_path[:] = [
            item for item in sys.meta_path if item.__module__.startswith("_frozen_importlib")
        ]
        with TemporaryDirectory() as tmp_dir:
            tmp_path = Path(tmp_dir)
            module_name = "dp_meta_path_temp"
            module_path = tmp_path / f"{module_name}.py"
            module_path.write_text(
                textwrap.dedent(
                    """\
                    # diet-python: disable
                    VALUE = 1
                    """
                ),
                encoding="utf-8",
            )
            sys.path.insert(0, str(tmp_path))
            try:
                sys.modules.pop(module_name, None)
                importlib.import_module(module_name)
                return True
            finally:
                sys.modules.pop(module_name, None)
                if sys.path and sys.path[0] == str(tmp_path):
                    sys.path.pop(0)
    except ModuleNotFoundError:
        return False
    finally:
        sys.meta_path[:] = original_meta_path
=
importlib = __dp__.import_("importlib", __spec__)
sys = __dp__.import_("sys", __spec__)
textwrap = __dp__.import_("textwrap", __spec__)
_dp_import_1 = __dp__.import_("pathlib", __spec__, __dp__.list(("Path",)))
Path = __dp__.import_attr(_dp_import_1, "Path")
del _dp_import_1
_dp_import_2 = __dp__.import_("tempfile", __spec__, __dp__.list(("TemporaryDirectory",)))
TemporaryDirectory = __dp__.import_attr(_dp_import_2, "TemporaryDirectory")
del _dp_import_2
diet_import_hook = __dp__.import_("diet_import_hook", __spec__)
def _dp_fn_import_with_filtered_meta_path() -> bool:
    diet_import_hook.install()
    original_meta_path = list(sys.meta_path)
    try:

        def _dp_gen_3(_dp_iter_4):
            _dp_iter_5 = __dp__.iter(_dp_iter_4)
            while True:
                try:
                    item = __dp__.next(_dp_iter_5)
                except:
                    __dp__.check_stopiteration()
                    break
                else:
                    if item.__module__.startswith("_frozen_importlib"):
                        yield item
        _dp_gen_3.__name__ = "<genexpr>"
        _dp_gen_3.__code__ = _dp_gen_3.__code__.replace(co_name="<genexpr>")
        _dp_gen_3 = __dp__.update_fn(_dp_gen_3, "import_with_filtered_meta_path.<locals>", "<genexpr>")
        __dp__.setitem(sys.meta_path, __dp__.slice(None, None, None), __dp__.list(_dp_gen_3(__dp__.iter(sys.meta_path))))
        _dp_with_enter_6 = __dp__.with_enter(TemporaryDirectory())
        tmp_dir = __dp__.getitem(_dp_with_enter_6, 0)
        _dp_with_exit_7 = __dp__.getitem(_dp_with_enter_6, 1)
        _dp_with_active_8 = True
        try:
            tmp_path = Path(tmp_dir)
            module_name = "dp_meta_path_temp"
            module_path = __dp__.truediv(tmp_path, "".join((__dp__.builtins.format(module_name), ".py")))
            module_path.write_text(textwrap.dedent("""                    # diet-python: disable\n                    VALUE = 1\n                    """), encoding="utf-8")
            sys.path.insert(0, str(tmp_path))
            try:
                sys.modules.pop(module_name, None)
                importlib.import_module(module_name)
                return True
            finally:
                sys.modules.pop(module_name, None)
                _dp_tmp_9 = sys.path
                if _dp_tmp_9:
                    _dp_tmp_10 = __dp__.eq(__dp__.getitem(sys.path, 0), str(tmp_path))
                    _dp_tmp_9 = _dp_tmp_10
                if _dp_tmp_9:
                    sys.path.pop(0)
        except:
            _dp_with_active_8 = False
            __dp__.with_exit(_dp_with_exit_7, __dp__.exc_info())
        finally:
            if _dp_with_active_8:
                __dp__.with_exit(_dp_with_exit_7, None)
            _dp_with_exit_7 = None
            _dp_with_enter_6 = None
    except:
        if __dp__.exception_matches(__dp__.current_exception(), ModuleNotFoundError):
            return False
        else:
            raise
    finally:
        __dp__.setitem(sys.meta_path, __dp__.slice(None, None, None), original_meta_path)
import_with_filtered_meta_path = __dp__.update_fn(_dp_fn_import_with_filtered_meta_path, None, "import_with_filtered_meta_path")

$ integration: with class mock calls

from unittest import mock


class Context:
    __enter__ = mock.MagicMock(return_value="value")
    __exit__ = mock.MagicMock(return_value=False)


def run():
    Context.__enter__.reset_mock()
    Context.__exit__.reset_mock()
    with Context():
        pass
    return Context.__enter__.mock_calls, Context.__exit__.mock_calls
=
_dp_import_1 = __dp__.import_("unittest", __spec__, __dp__.list(("mock",)))
mock = __dp__.import_attr(_dp_import_1, "mock")
del _dp_import_1
def _dp_create_class_Context():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_2():
            return __name__
        _dp_lambda_2.__name__ = "<lambda>"
        _dp_lambda_2.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_2)
        _dp_class_ns.__qualname__ = "Context"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_lambda_3():
            return mock
        _dp_lambda_3.__name__ = "<lambda>"
        _dp_lambda_3.__qualname__ = "<lambda>"
        _dp_class_ns.__enter__ = __dp__.class_lookup("mock", _dp_class_ns, _dp_lambda_3).MagicMock(return_value="value")

        def _dp_lambda_4():
            return mock
        _dp_lambda_4.__name__ = "<lambda>"
        _dp_lambda_4.__qualname__ = "<lambda>"
        _dp_class_ns.__exit__ = __dp__.class_lookup("mock", _dp_class_ns, _dp_lambda_4).MagicMock(return_value=False)
    return __dp__.create_class("Context", _dp_ns_builder, (), None)
Context = _dp_create_class_Context()
def _dp_fn_run():
    Context.__enter__.reset_mock()
    Context.__exit__.reset_mock()
    _dp_with_enter_5 = __dp__.with_enter(Context())
    _ = __dp__.getitem(_dp_with_enter_5, 0)
    _dp_with_exit_6 = __dp__.getitem(_dp_with_enter_5, 1)
    _dp_with_active_7 = True
    try:
        pass
    except:
        _dp_with_active_7 = False
        __dp__.with_exit(_dp_with_exit_6, __dp__.exc_info())
    finally:
        if _dp_with_active_7:
            __dp__.with_exit(_dp_with_exit_6, None)
        _dp_with_exit_6 = None
        _dp_with_enter_5 = None
    return Context.__enter__.mock_calls, Context.__exit__.mock_calls
run = __dp__.update_fn(_dp_fn_run, None, "run")

$ integration: exception refcycle after except

import gc


def run():
    exc = None
    try:
        raise RuntimeError("boom")
    except RuntimeError as e:
        exc = e
    return gc.get_referrers(exc)
=
gc = __dp__.import_("gc", __spec__)
def _dp_fn_run():
    exc = None
    try:
        raise RuntimeError("boom")
    except:
        if __dp__.exception_matches(__dp__.current_exception(), RuntimeError):
            e = __dp__.current_exception()
            try:
                exc = e
            finally:
                try:
                    del e
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError):
                        pass
                    else:
                        raise
        else:
            raise
    return gc.get_referrers(exc)
run = __dp__.update_fn(_dp_fn_run, None, "run")

$ integration: taskgroup propagate cancellation refcycle

import asyncio
import gc


def run():
    exc = None
    try:
        try:
            raise asyncio.CancelledError()
        except asyncio.CancelledError as err:
            raise TimeoutError from err
    except TimeoutError as err:
        exc = err.__cause__
    return gc.get_referrers(exc)
=
asyncio = __dp__.import_("asyncio", __spec__)
gc = __dp__.import_("gc", __spec__)
def _dp_fn_run():
    exc = None
    try:
        try:
            raise asyncio.CancelledError()
        except:
            if __dp__.exception_matches(__dp__.current_exception(), asyncio.CancelledError):
                err = __dp__.current_exception()
                try:
                    raise __dp__.raise_from(TimeoutError, err)
                finally:
                    try:
                        del err
                    except:
                        if __dp__.exception_matches(__dp__.current_exception(), NameError):
                            pass
                        else:
                            raise
            else:
                raise
    except:
        if __dp__.exception_matches(__dp__.current_exception(), TimeoutError):
            err = __dp__.current_exception()
            try:
                exc = err.__cause__
            finally:
                try:
                    del err
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError):
                        pass
                    else:
                        raise
        else:
            raise
    return gc.get_referrers(exc)
run = __dp__.update_fn(_dp_fn_run, None, "run")

$ integration: traceback preserves comments

import traceback


def run():
    try:
        1 / 0  # search target
    except ZeroDivisionError:
        return traceback.format_exc()
=
traceback = __dp__.import_("traceback", __spec__)
def _dp_fn_run():
    try:
        __dp__.truediv(1, 0)
    except:
        if __dp__.exception_matches(__dp__.current_exception(), ZeroDivisionError):
            return traceback.format_exc()
        else:
            raise
run = __dp__.update_fn(_dp_fn_run, None, "run")

$ integration: traceback linecache clear

import contextlib
import io
import linecache
import sys


class Reporter:
    def run(self):
        try:
            exc = ValueError("boom")
            raise exc
        except ValueError:
            linecache.clearcache()
            buffer = io.StringIO()
            with contextlib.redirect_stderr(buffer):
                sys.__excepthook__(*sys.exc_info())
            return buffer.getvalue()


def get_report():
    return Reporter().run()
=
contextlib = __dp__.import_("contextlib", __spec__)
io = __dp__.import_("io", __spec__)
linecache = __dp__.import_("linecache", __spec__)
sys = __dp__.import_("sys", __spec__)
def _dp_create_class_Reporter():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_4():
            return __name__
        _dp_lambda_4.__name__ = "<lambda>"
        _dp_lambda_4.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_4)
        _dp_class_ns.__qualname__ = "Reporter"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_fn_run(self):
            try:
                exc = ValueError("boom")
                raise exc
            except:
                if __dp__.exception_matches(__dp__.current_exception(), ValueError):
                    linecache.clearcache()
                    buffer = io.StringIO()
                    _dp_with_enter_1 = __dp__.with_enter(contextlib.redirect_stderr(buffer))
                    _ = __dp__.getitem(_dp_with_enter_1, 0)
                    _dp_with_exit_2 = __dp__.getitem(_dp_with_enter_1, 1)
                    _dp_with_active_3 = True
                    try:
                        sys.__excepthook__(*sys.exc_info())
                    except:
                        _dp_with_active_3 = False
                        __dp__.with_exit(_dp_with_exit_2, __dp__.exc_info())
                    finally:
                        if _dp_with_active_3:
                            __dp__.with_exit(_dp_with_exit_2, None)
                        _dp_with_exit_2 = None
                        _dp_with_enter_1 = None
                    return buffer.getvalue()
                else:
                    raise
        _dp_class_ns.run = __dp__.update_fn(_dp_fn_run, "Reporter", "run")
    return __dp__.create_class("Reporter", _dp_ns_builder, (), None)
Reporter = _dp_create_class_Reporter()
def _dp_fn_get_report():
    return Reporter().run()
get_report = __dp__.update_fn(_dp_fn_get_report, None, "get_report")

$ integration: surrogate unicode escape repr

def repr_value():
    char = "\uDCBA"
    return repr(char)


def ascii_value():
    char = "\uDCBA"
    return ascii(char)
=
def _dp_fn_repr_value():
    char = ""
    return repr(char)
repr_value = __dp__.update_fn(_dp_fn_repr_value, None, "repr_value")
def _dp_fn_ascii_value():
    char = ""
    return ascii(char)
ascii_value = __dp__.update_fn(_dp_fn_ascii_value, None, "ascii_value")

$ integration: lambda qualname

def global_function():
    return (lambda: None).__qualname__, (lambda: None).__name__
=
def _dp_fn_global_function():

    def _dp_lambda_1():
        return None
    _dp_lambda_1.__name__ = "<lambda>"
    _dp_lambda_1.__qualname__ = "global_function.<locals>.<lambda>"

    def _dp_lambda_2():
        return None
    _dp_lambda_2.__name__ = "<lambda>"
    _dp_lambda_2.__qualname__ = "global_function.<locals>.<lambda>"
    return _dp_lambda_1.__qualname__, _dp_lambda_2.__name__
global_function = __dp__.update_fn(_dp_fn_global_function, None, "global_function")

$ integration: yield from stack names

import sys


def get_stack_names():

    def f():
        frame = sys._getframe()
        yield frame.f_code.co_name, frame.f_back.f_code.co_name

    def g():
        yield from f()

    gen = g()
    return gen.send(None)
=
sys = __dp__.import_("sys", __spec__)
def _dp_fn_get_stack_names():

    def _dp_fn_f():
        frame = sys._getframe()
        yield frame.f_code.co_name, frame.f_back.f_code.co_name
    f = __dp__.update_fn(_dp_fn_f, "get_stack_names.<locals>", "f")

    def _dp_fn_g():
        yield from f()
    g = __dp__.update_fn(_dp_fn_g, "get_stack_names.<locals>", "g")
    gen = g()
    return gen.send(None)
get_stack_names = __dp__.update_fn(_dp_fn_get_stack_names, None, "get_stack_names")

$ integration: yield from gi_yieldfrom

def get_yieldfrom_name():

    def a():
        yield

    def b():
        yield from a()
        yield
    gen_b = b()
    gen_b.send(None)
    return gen_b.gi_yieldfrom.gi_code.co_name
=
def _dp_fn_get_yieldfrom_name():

    def _dp_fn_a():
        yield
    a = __dp__.update_fn(_dp_fn_a, "get_yieldfrom_name.<locals>", "a")

    def _dp_fn_b():
        yield from a()
        yield
    b = __dp__.update_fn(_dp_fn_b, "get_yieldfrom_name.<locals>", "b")
    gen_b = b()
    gen_b.send(None)
    return gen_b.gi_yieldfrom.gi_code.co_name
get_yieldfrom_name = __dp__.update_fn(_dp_fn_get_yieldfrom_name, None, "get_yieldfrom_name")

$ integration: genexpr name

def get_genexpr_name():
    gen = (i for i in ())
    return gen.__name__
=
def _dp_fn_get_genexpr_name():

    def _dp_gen_1(_dp_iter_2):
        _dp_iter_3 = __dp__.iter(_dp_iter_2)
        while True:
            try:
                i = __dp__.next(_dp_iter_3)
            except:
                __dp__.check_stopiteration()
                break
            else:
                yield i
    _dp_gen_1.__name__ = "<genexpr>"
    _dp_gen_1.__code__ = _dp_gen_1.__code__.replace(co_name="<genexpr>")
    _dp_gen_1 = __dp__.update_fn(_dp_gen_1, "get_genexpr_name.<locals>", "<genexpr>")
    gen = _dp_gen_1(__dp__.iter(()))
    return gen.__name__
get_genexpr_name = __dp__.update_fn(_dp_fn_get_genexpr_name, None, "get_genexpr_name")

$ integration: nested class base

class Outer:
    class BaseThing(str):
        pass

    class Thing(BaseThing):
        pass


def get_base_name():
    return Outer.Thing.__bases__[0].__name__
=
def _dp_create_class_Outer():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_5():
            return __name__
        _dp_lambda_5.__name__ = "<lambda>"
        _dp_lambda_5.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_5)
        _dp_class_ns.__qualname__ = "Outer"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_create_class_Outer_BaseThing():

            def _dp_ns_builder(_dp_class_ns):

                def _dp_lambda_1():
                    return __name__
                _dp_lambda_1.__name__ = "<lambda>"
                _dp_lambda_1.__qualname__ = "Outer.<lambda>"
                _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_1)
                _dp_class_ns.__qualname__ = "Outer.BaseThing"
                _dp_class_ns.__annotations__ = __dp__.dict()

            def _dp_lambda_2():
                return str
            _dp_lambda_2.__name__ = "<lambda>"
            _dp_lambda_2.__qualname__ = "Outer.<lambda>"
            return __dp__.create_class("BaseThing", _dp_ns_builder, (__dp__.class_lookup("str", _dp_class_ns, _dp_lambda_2),), None)
        _dp_class_ns.BaseThing = _dp_create_class_Outer_BaseThing()

        def _dp_create_class_Outer_Thing():

            def _dp_ns_builder(_dp_class_ns):

                def _dp_lambda_3():
                    return __name__
                _dp_lambda_3.__name__ = "<lambda>"
                _dp_lambda_3.__qualname__ = "Outer.<lambda>"
                _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_3)
                _dp_class_ns.__qualname__ = "Outer.Thing"
                _dp_class_ns.__annotations__ = __dp__.dict()

            def _dp_lambda_4():
                return BaseThing
            _dp_lambda_4.__name__ = "<lambda>"
            _dp_lambda_4.__qualname__ = "Outer.<lambda>"
            return __dp__.create_class("Thing", _dp_ns_builder, (__dp__.class_lookup("BaseThing", _dp_class_ns, _dp_lambda_4),), None)
        _dp_class_ns.Thing = _dp_create_class_Outer_Thing()
    return __dp__.create_class("Outer", _dp_ns_builder, (), None)
Outer = _dp_create_class_Outer()
def _dp_fn_get_base_name():
    return __dp__.getitem(Outer.Thing.__bases__, 0).__name__
get_base_name = __dp__.update_fn(_dp_fn_get_base_name, None, "get_base_name")

$ integration: future import invalid feature

from __future__ import not_a_feature

VALUE = 1
=
from __future__ import not_a_feature
VALUE = 1

$ integration: typevar tuple default none

class A[*Ts]:
    pass
=
def _dp_create_class_A():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_1():
            return __name__
        _dp_lambda_1.__name__ = "<lambda>"
        _dp_lambda_1.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_1)
        _dp_class_ns.__qualname__ = "A"
        _dp_class_ns.Ts = __dp__.type_param_typevar_tuple("Ts", None)

        def _dp_lambda_2():
            return Ts
        _dp_lambda_2.__name__ = "<lambda>"
        _dp_lambda_2.__qualname__ = "<lambda>"
        _dp_class_ns.__type_params__ = __dp__.class_lookup("Ts", _dp_class_ns, _dp_lambda_2),
        _dp_class_ns.__annotations__ = __dp__.dict()
    return __dp__.create_class("A", _dp_ns_builder, (), None)
A = _dp_create_class_A()

$ integration: io.open class attr

import io


class Reader:
    open = io.open


def read_self():
    with Reader().open(__file__, "rb") as handle:
        return handle.read(1)


RESULT = read_self()
=
io = __dp__.import_("io", __spec__)
def _dp_create_class_Reader():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_1():
            return __name__
        _dp_lambda_1.__name__ = "<lambda>"
        _dp_lambda_1.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_1)
        _dp_class_ns.__qualname__ = "Reader"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_lambda_2():
            return io
        _dp_lambda_2.__name__ = "<lambda>"
        _dp_lambda_2.__qualname__ = "<lambda>"
        _dp_class_ns.open = __dp__.class_lookup("io", _dp_class_ns, _dp_lambda_2).open
    return __dp__.create_class("Reader", _dp_ns_builder, (), None)
Reader = _dp_create_class_Reader()
def _dp_fn_read_self():
    _dp_with_enter_3 = __dp__.with_enter(Reader().open(__file__, "rb"))
    handle = __dp__.getitem(_dp_with_enter_3, 0)
    _dp_with_exit_4 = __dp__.getitem(_dp_with_enter_3, 1)
    _dp_with_active_5 = True
    try:
        return handle.read(1)
    except:
        _dp_with_active_5 = False
        __dp__.with_exit(_dp_with_exit_4, __dp__.exc_info())
    finally:
        if _dp_with_active_5:
            __dp__.with_exit(_dp_with_exit_4, None)
        _dp_with_exit_4 = None
        _dp_with_enter_3 = None
read_self = __dp__.update_fn(_dp_fn_read_self, None, "read_self")
RESULT = read_self()

$ integration: class kwarg metaclass expansion

class Meta(int):
    def __init__(*args, **kwargs):
        pass

    def __new__(cls, name, bases, attrs, **kwargs):
        return bases, kwargs


d = {"metaclass": Meta}


class A(**d):
    pass


RESULT = A
=
def _dp_create_class_Meta():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_1():
            return __name__
        _dp_lambda_1.__name__ = "<lambda>"
        _dp_lambda_1.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_1)
        _dp_class_ns.__qualname__ = "Meta"
        _dp_class_ns.__annotations__ = __dp__.dict()

        def _dp_fn___init__(*args, **kwargs):
            pass
        _dp_class_ns.__init__ = __dp__.update_fn(_dp_fn___init__, "Meta", "__init__")

        def _dp_fn___new__(cls, name, bases, attrs, **kwargs):
            return bases, kwargs
        _dp_class_ns.__new__ = __dp__.update_fn(_dp_fn___new__, "Meta", "__new__")
    return __dp__.create_class("Meta", _dp_ns_builder, (int,), None)
Meta = _dp_create_class_Meta()
d = __dp__.dict((("metaclass", Meta),))
def _dp_create_class_A():

    def _dp_ns_builder(_dp_class_ns):

        def _dp_lambda_2():
            return __name__
        _dp_lambda_2.__name__ = "<lambda>"
        _dp_lambda_2.__qualname__ = "<lambda>"
        _dp_class_ns.__module__ = __dp__.class_lookup("__name__", _dp_class_ns, _dp_lambda_2)
        _dp_class_ns.__qualname__ = "A"
        _dp_class_ns.__annotations__ = __dp__.dict()
    return __dp__.create_class("A", _dp_ns_builder, (), __dp__.dict(d))
A = _dp_create_class_A()
RESULT = A
