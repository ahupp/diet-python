$ rewrites function decorators

@dec2(5)
@dec1
def foo():
    pass
=
def foo():
    pass
foo = dec2(5)(dec1(foo))

$ preserves annotations on decorated functions

@dec
def foo(x: int) -> str:
    pass
=
def foo(x: int$0) -> str$0:
    pass
foo = dec(foo)

$ rewrites class decorators

@dec
class C:
    pass
=
def _dp_ns_C(_dp_class_ns):

    def _dp_lambda_1():
        return __name__$0
    _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
    __dp__.setattr(_dp_class_ns, "__qualname__", "C")
C = __dp__.create_class("C", _dp_ns_C, (), None)
C = dec(C)

$ rewrites multiple class decorators

@dec2(5)
@dec1
class C:
    pass
=
def _dp_ns_C(_dp_class_ns):

    def _dp_lambda_1():
        return __name__$0
    _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
    __dp__.setattr(_dp_class_ns, "__qualname__", "C")
C = __dp__.create_class("C", _dp_ns_C, (), None)
C = dec2(5)(dec1(C))

$ preserves existing decorator targets

atexit = property(lambda: None)

@atexit.setter
def atexit(value):
    pass
=
def _dp_lambda_1():
    return None
_dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, None, "<lambda>")
atexit = property(_dp_lambda_1)
def atexit(value):
    pass
atexit = atexit.setter(atexit)
