$ integration: multiprocessing barrier abort reset
import multiprocessing as mp
import queue
import threading


def _participant(barrier, barrier2, result_queue):
    try:
        index = barrier.wait()
        if index == 1:
            raise RuntimeError("boom")
        barrier.wait()
    except threading.BrokenBarrierError:
        result_queue.put("broken")
    except RuntimeError:
        barrier.abort()

    try:
        if barrier2.wait() == 1:
            barrier.reset()
        barrier2.wait()
        barrier.wait()
        result_queue.put("done")
    except threading.BrokenBarrierError:
        result_queue.put("barrier2_broken")


def run() -> bool:
    ctx = mp.get_context("spawn")
    barrier = ctx.Barrier(3, timeout=2.0)
    barrier2 = ctx.Barrier(3, timeout=2.0)
    result_queue = ctx.Queue()

    processes = [
        ctx.Process(target=_participant, args=(barrier, barrier2, result_queue))
        for _ in range(2)
    ]
    for proc in processes:
        proc.start()

    _participant(barrier, barrier2, result_queue)

    for proc in processes:
        proc.join(5)

    if any(proc.is_alive() for proc in processes):
        for proc in processes:
            proc.terminate()
        return False

    results = []
    while len(results) < 3:
        try:
            results.append(result_queue.get(timeout=1))
        except queue.Empty:
            break

    return results.count("done") == 3 and "barrier2_broken" not in results
=
mp = __dp__.import_("multiprocessing", __spec__)
queue = __dp__.import_("queue", __spec__)
threading = __dp__.import_("threading", __spec__)
def _participant(barrier, barrier2, result_queue):
    try:
        index = barrier.wait()
        _dp_target_1 = __dp__.eq(index, 1)
        if _dp_target_1:
            raise RuntimeError("boom")
        barrier.wait()
    except:
        if __dp__.exception_matches(__dp__.current_exception(), threading.BrokenBarrierError):
            result_queue.put("broken")
        else:
            if __dp__.exception_matches(__dp__.current_exception(), RuntimeError):
                barrier.abort()
            else:
                raise
    try:
        _dp_target_2 = __dp__.eq(barrier2.wait(), 1)
        if _dp_target_2:
            barrier.reset()
        barrier2.wait()
        barrier.wait()
        result_queue.put("done")
    except:
        if __dp__.exception_matches(__dp__.current_exception(), threading.BrokenBarrierError):
            result_queue.put("barrier2_broken")
        else:
            raise
def run() -> bool:
    ctx = mp.get_context("spawn")
    barrier = ctx.Barrier(3, timeout=2.0)
    barrier2 = ctx.Barrier(3, timeout=2.0)
    result_queue = ctx.Queue()

    def _dp_gen_3(_dp_iter_4):
        _dp_iter_5 = __dp__.iter(_dp_iter_4)
        try:
            while True:
                _ = __dp__.next(_dp_iter_5)
                yield ctx.Process(target=_participant, args=(barrier, barrier2, result_queue))
        except:
            if __dp__.exception_matches(__dp__.current_exception(), StopIteration):
                pass
            else:
                raise
    _dp_gen_3 = __dp__.update_fn(_dp_gen_3, "run.<locals>", "<genexpr>")
    processes = __dp__.list(_dp_gen_3(__dp__.iter(range(2))))
    _dp_iter_6 = __dp__.iter(processes)
    try:
        while True:
            proc = __dp__.next(_dp_iter_6)
            proc.start()
    except:
        if __dp__.exception_matches(__dp__.current_exception(), StopIteration):
            pass
        else:
            raise
    _participant(barrier, barrier2, result_queue)
    _dp_iter_7 = __dp__.iter(processes)
    try:
        while True:
            proc = __dp__.next(_dp_iter_7)
            proc.join(5)
    except:
        if __dp__.exception_matches(__dp__.current_exception(), StopIteration):
            pass
        else:
            raise

    def _dp_gen_14(_dp_iter_15):
        _dp_iter_16 = __dp__.iter(_dp_iter_15)
        try:
            while True:
                proc = __dp__.next(_dp_iter_16)
                yield proc.is_alive()
        except:
            if __dp__.exception_matches(__dp__.current_exception(), StopIteration):
                pass
            else:
                raise
    _dp_gen_14 = __dp__.update_fn(_dp_gen_14, "run.<locals>", "<genexpr>")
    if any(_dp_gen_14(__dp__.iter(processes))):
        _dp_iter_8 = __dp__.iter(processes)
        try:
            while True:
                proc = __dp__.next(_dp_iter_8)
                proc.terminate()
        except:
            if __dp__.exception_matches(__dp__.current_exception(), StopIteration):
                pass
            else:
                raise
        return False
    results = __dp__.list(())
    _dp_test_flag_9 = True
    while True:
        _dp_target_10 = __dp__.lt(len(results), 3)
        _dp_test_flag_9 = _dp_target_10
        if __dp__.not_(_dp_test_flag_9):
            break
        try:
            results.append(result_queue.get(timeout=1))
        except:
            if __dp__.exception_matches(__dp__.current_exception(), queue.Empty):
                break
            else:
                raise
    if _dp_test_flag_9:
        pass
    _dp_target_12 = __dp__.eq(results.count("done"), 3)
    _dp_target_11 = _dp_target_12
    if _dp_target_11:
        _dp_target_13 = __dp__.not_(__dp__.contains(results, "barrier2_broken"))
        _dp_target_11 = _dp_target_13
    return _dp_target_11
