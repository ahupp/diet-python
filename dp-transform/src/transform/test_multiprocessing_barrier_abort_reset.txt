$ integration: multiprocessing barrier abort reset
import multiprocessing as mp
import queue
import threading


def _participant(barrier, barrier2, result_queue):
    try:
        index = barrier.wait()
        if index == 1:
            raise RuntimeError("boom")
        barrier.wait()
    except threading.BrokenBarrierError:
        result_queue.put("broken")
    except RuntimeError:
        barrier.abort()

    try:
        if barrier2.wait() == 1:
            barrier.reset()
        barrier2.wait()
        barrier.wait()
        result_queue.put("done")
    except threading.BrokenBarrierError:
        result_queue.put("barrier2_broken")


def run() -> bool:
    ctx = mp.get_context("spawn")
    barrier = ctx.Barrier(3, timeout=2.0)
    barrier2 = ctx.Barrier(3, timeout=2.0)
    result_queue = ctx.Queue()

    processes = [
        ctx.Process(target=_participant, args=(barrier, barrier2, result_queue))
        for _ in range(2)
    ]
    for proc in processes:
        proc.start()

    _participant(barrier, barrier2, result_queue)

    for proc in processes:
        proc.join(5)

    if any(proc.is_alive() for proc in processes):
        for proc in processes:
            proc.terminate()
        return False

    results = []
    while len(results) < 3:
        try:
            results.append(result_queue.get(timeout=1))
        except queue.Empty:
            break

    return results.count("done") == 3 and "barrier2_broken" not in results
=
mp = __dp__.import_("multiprocessing", __spec__)
queue = __dp__.import_("queue", __spec__)
threading = __dp__.import_("threading", __spec__)
def _dp_fn__participant(barrier, barrier2, result_queue):
    try:
        index = barrier.wait()
        _dp_tmp_1 = __dp__.eq(index, 1)
        if _dp_tmp_1:
            raise RuntimeError$0("boom")
        barrier.wait()
    except:
        if __dp__.exception_matches(__dp__.current_exception(), threading$0.BrokenBarrierError):
            result_queue.put("broken")
        else:
            if __dp__.exception_matches(__dp__.current_exception(), RuntimeError$0):
                barrier.abort()
            else:
                raise
    try:
        _dp_tmp_2 = __dp__.eq(barrier2.wait(), 1)
        if _dp_tmp_2:
            barrier.reset()
        barrier2.wait()
        barrier.wait()
        result_queue.put("done")
    except:
        if __dp__.exception_matches(__dp__.current_exception(), threading$0.BrokenBarrierError):
            result_queue.put("barrier2_broken")
        else:
            raise
_participant = __dp__.update_fn(_dp_fn__participant, None, "_participant")
del _dp_fn__participant
def _dp_fn_run() -> bool$0:
    ctx = mp$0.get_context("spawn")
    barrier = ctx.Barrier(3, timeout=2.0)
    barrier2 = ctx.Barrier(3, timeout=2.0)
    result_queue = ctx.Queue()

    def _dp_gen_3(_dp_iter_4):
        _dp_iter_5 = __dp__.iter(_dp_iter_4)
        while True:
            try:
                _ = __dp__.next(_dp_iter_5)
            except:
                __dp__.check_stopiteration()
                break
            else:
                yield ctx$1.Process(target=_participant$0, args=(barrier$1, barrier2$1, result_queue$1))
    _dp_gen_3.__name__ = "<genexpr>"
    _dp_gen_3.__code__ = _dp_gen_3.__code__.replace(co_name="<genexpr>")
    _dp_gen_3 = __dp__.update_fn(_dp_gen_3, "run.<locals>", "<genexpr>")
    processes = __dp__.list(_dp_gen_3(__dp__.iter(range$0(2))))
    _dp_iter_6 = __dp__.iter(processes)
    while True:
        try:
            proc = __dp__.next(_dp_iter_6)
        except:
            __dp__.check_stopiteration()
            break
        else:
            proc.start()
    _participant$0(barrier, barrier2, result_queue)
    _dp_iter_7 = __dp__.iter(processes)
    while True:
        try:
            proc = __dp__.next(_dp_iter_7)
        except:
            __dp__.check_stopiteration()
            break
        else:
            proc.join(5)

    def _dp_gen_8(_dp_iter_9):
        _dp_iter_11 = __dp__.iter(_dp_iter_9)
        while True:
            try:
                proc = __dp__.next(_dp_iter_11)
            except:
                __dp__.check_stopiteration()
                break
            else:
                yield proc.is_alive()
    _dp_gen_8.__name__ = "<genexpr>"
    _dp_gen_8.__code__ = _dp_gen_8.__code__.replace(co_name="<genexpr>")
    _dp_gen_8 = __dp__.update_fn(_dp_gen_8, "run.<locals>", "<genexpr>")
    if any$0(_dp_gen_8(__dp__.iter(processes))):
        _dp_iter_10 = __dp__.iter(processes)
        while True:
            try:
                proc = __dp__.next(_dp_iter_10)
            except:
                __dp__.check_stopiteration()
                break
            else:
                proc.terminate()
        return False
    results = __dp__.list(())
    while True:
        _dp_tmp_12 = __dp__.lt(len$0(results), 3)
        if __dp__.not_(_dp_tmp_12):
            break
        try:
            results.append(result_queue.get(timeout=1))
        except:
            if __dp__.exception_matches(__dp__.current_exception(), queue$0.Empty):
                break
            else:
                raise
    _dp_tmp_14 = __dp__.eq(results.count("done"), 3)
    _dp_tmp_13 = _dp_tmp_14
    if _dp_tmp_13:
        _dp_tmp_15 = __dp__.not_(__dp__.contains(results, "barrier2_broken"))
        _dp_tmp_13 = _dp_tmp_15
    return _dp_tmp_13
run = __dp__.update_fn(_dp_fn_run, None, "run")
del _dp_fn_run
