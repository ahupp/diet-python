$ obscure super errors

from __future__ import annotations


def exercise():
    class X:
        def f(x):
            nonlocal __class__
            del __class__
            super()

    try:
        X().f()
    except Exception as exc:
        return type(exc), str(exc)

    return None, None
=
def exercise():

    def _dp_ns_X(_dp_class_ns):

        def _dp_lambda_1():
            return __name__
        _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, "exercise.<locals>", "<lambda>")
        __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
        __dp__.setattr(_dp_class_ns, "__qualname__", "exercise.<locals>.X")

        def f(x):
            nonlocal __class__
            del __class__
            super()

        def _dp_lambda_2():
            return f
        _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, "exercise.<locals>", "<lambda>")
        __dp__.setattr(_dp_class_ns, "f", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "f", _dp_lambda_2), "exercise.<locals>.X", "<locals>"))
    X = __dp__.create_class("X", _dp_ns_X, (), None)
    try:
        getattr(X(), "f")()
    except:
        if __dp__.exception_matches(__dp__.current_exception(), Exception):
            exc = __dp__.current_exception()
            try:
                return type(exc), str(exc)
            finally:
                try:
                    del exc
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError):
                        pass
                    else:
                        raise
        else:
            raise
    return None, None
