$ strips type alias statement

type Alias = int
=
type Alias = int

$ preserves float literal precision

VALUE = 0.9999999999999999
=
VALUE = __dp__.float_from_literal("0.9999999999999999")

$ strips type aliases in if branches

if True:
    type Alias = int
    x = 1
elif False:
    type Alias = str
    y = 2
else:
    type Alias = bytes
    z = 3
=
if True:
    type Alias = int
    x = 1
else:
    if False:
        type Alias = str
        y = 2
    else:
        type Alias = bytes
        z = 3

$ strips type alias from class body

type Alias = int

class Foo:
    type Inner = str

    def method(self):
        return 1
=
type Alias = int
def _dp_ns_Foo(_dp_class_ns):

    def _dp_lambda_1():
        return __name__$0
    _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Foo")

    def _dp_type_alias_Inner():

        def _dp_lambda_2():
            return str$0
        _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, None, "<lambda>")
        type Inner = __dp__.class_lookup(_dp_class_ns, "str", _dp_lambda_2)
        return Inner
    __dp__.setattr(_dp_class_ns, "Inner", _dp_type_alias_Inner())

    def method(self):
        return 1

    def _dp_lambda_3():
        return method$0
    _dp_lambda_3 = __dp__.update_fn(_dp_lambda_3, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "method", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "method", _dp_lambda_3), "Foo", "<locals>"))
Foo = __dp__.create_class("Foo", _dp_ns_Foo, (), None)

$ integration: class lookup lambda avoids recursion

class Example:
    value = __name__

RESULT = Example.value
=
def _dp_ns_Example(_dp_class_ns):

    def _dp_lambda_1():
        return __name__$0
    _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Example")

    def _dp_lambda_2():
        return __name__$0
    _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "value", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_2))
Example = __dp__.create_class("Example", _dp_ns_Example, (), None)
RESULT = Example.value

$ class method name does not shadow module

import time

class Base:
    def __init__(self):
        self.resolution = time.get_clock_info("monotonic").resolution

    def time(self):
        return time.monotonic()

VALUE = Base().resolution
=
time = __dp__.import_("time", __spec__)
def _dp_ns_Base(_dp_class_ns):

    def _dp_lambda_1():
        return __name__$0
    _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Base")

    def __init__(self):
        __dp__.setattr(self, "resolution", getattr$0(time$0.get_clock_info("monotonic"), "resolution"))

    def _dp_lambda_2():
        return __init__$0
    _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__init__", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "__init__", _dp_lambda_2), "Base", "<locals>"))

    def time(self):
        return time$0.monotonic()

    def _dp_lambda_3():
        return time$0
    _dp_lambda_3 = __dp__.update_fn(_dp_lambda_3, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "time", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "time", _dp_lambda_3), "Base", "<locals>"))
Base = __dp__.create_class("Base", _dp_ns_Base, (), None)
VALUE = getattr(Base(), "resolution")

$ integration: class namespace get method

import types

class Example:
    def get(self):
        return "value"

    __class_getitem__ = classmethod(types.GenericAlias)

RESULT = Example[int]
=
types = __dp__.import_("types", __spec__)
def _dp_ns_Example(_dp_class_ns):

    def _dp_lambda_1():
        return __name__$0
    _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Example")

    def get(self):
        return "value"

    def _dp_lambda_2():
        return get$0
    _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "get", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "get", _dp_lambda_2), "Example", "<locals>"))

    def _dp_lambda_3():
        return classmethod$0
    _dp_lambda_3 = __dp__.update_fn(_dp_lambda_3, None, "<lambda>")

    def _dp_lambda_4():
        return types$0
    _dp_lambda_4 = __dp__.update_fn(_dp_lambda_4, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__class_getitem__", __dp__.class_lookup(_dp_class_ns, "classmethod", _dp_lambda_3)(getattr$0(__dp__.class_lookup(_dp_class_ns, "types", _dp_lambda_4), "GenericAlias")))
Example = __dp__.create_class("Example", _dp_ns_Example, (), None)
RESULT = __dp__.getitem(Example, int)

$ class method import does not shadow class locals

class Example:
    atexit = "class"

    def __init__(self):
        import atexit
        self.module_name = atexit.__name__

VALUE = Example().module_name
CLASS_ATTR = Example.atexit
=
def _dp_ns_Example(_dp_class_ns):

    def _dp_lambda_1():
        return __name__$0
    _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Example")
    __dp__.setattr(_dp_class_ns, "atexit", "class")

    def __init__(self):
        atexit = __dp__.import_("atexit", __spec__$0)
        __dp__.setattr(self, "module_name", atexit.__name__)

    def _dp_lambda_2():
        return __init__$0
    _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__init__", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "__init__", _dp_lambda_2), "Example", "<locals>"))
Example = __dp__.create_class("Example", _dp_ns_Example, (), None)
VALUE = getattr(Example(), "module_name")
CLASS_ATTR = Example.atexit

$ super uses defining class even if name is rebound

class Base:
    def __init__(self):
        self.value = "base"

class Derived(Base):
    def __init__(self):
        super().__init__()
        self.child = True

Alias = Derived
Derived = dict

INSTANCE = Alias()
VALUE = INSTANCE.value
=
def _dp_ns_Base(_dp_class_ns):

    def _dp_lambda_1():
        return __name__$0
    _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Base")

    def __init__(self):
        __dp__.setattr(self, "value", "base")

    def _dp_lambda_2():
        return __init__$0
    _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__init__", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "__init__", _dp_lambda_2), "Base", "<locals>"))
Base = __dp__.create_class("Base", _dp_ns_Base, (), None)
def _dp_ns_Derived(_dp_class_ns):

    def _dp_lambda_3():
        return __name__$0
    _dp_lambda_3 = __dp__.update_fn(_dp_lambda_3, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_3))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Derived")

    def __init__(self):
        getattr$0(super$0(), "__init__")()
        __dp__.setattr(self, "child", True)

    def _dp_lambda_4():
        return __init__$0
    _dp_lambda_4 = __dp__.update_fn(_dp_lambda_4, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__init__", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "__init__", _dp_lambda_4), "Derived", "<locals>"))
Derived = __dp__.create_class("Derived", _dp_ns_Derived, (Base,), None)
Alias = Derived
Derived = dict
INSTANCE = Alias()
VALUE = INSTANCE.value

$ async future traceback includes await line

import asyncio
import traceback

async def raise_exc():
    raise TypeError(42)

async def run():
    fut = asyncio.create_task(raise_exc())
    for _ in range(1):
        try:
            await fut
        except TypeError as exc:
            tb = "".join(traceback.format_tb(exc.__traceback__))
            return tb.count("await fut")
    return -1

COUNT = asyncio.run(run())
=
asyncio = __dp__.import_("asyncio", __spec__)
traceback = __dp__.import_("traceback", __spec__)
async def raise_exc():
    raise TypeError$0(42)
async def run():
    fut = asyncio$0.create_task(raise_exc$0())
    _dp_iter_1 = __dp__.iter(range$0(1))
    try:
        while True:
            _ = __dp__.next(_dp_iter_1)
            try:
                await fut
            except:
                if __dp__.exception_matches(__dp__.current_exception(), TypeError$0):
                    exc = __dp__.current_exception()
                    try:
                        tb = getattr$0("", "join")(traceback$0.format_tb(exc.__traceback__))
                        return tb.count("await fut")
                    finally:
                        try:
                            del exc
                        except:
                            if __dp__.exception_matches(__dp__.current_exception(), NameError$0):
                                pass
                            else:
                                raise
                else:
                    raise
    except:
        if __dp__.exception_matches(__dp__.current_exception(), StopIteration$0):
            pass
        else:
            raise
    return __dp__.neg(1)
COUNT = asyncio.run(run())

$ nested class method name does not shadow outer method

import time

class Outer:
    def format_help(self):
        return "outer"

    class Inner:
        def format_help(self):
            return time.get_clock_info("monotonic").resolution

VALUE = Outer.Inner().format_help()
=
time = __dp__.import_("time", __spec__)
def _dp_ns_Outer(_dp_class_ns):

    def _dp_lambda_3():
        return __name__$0
    _dp_lambda_3 = __dp__.update_fn(_dp_lambda_3, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_3))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Outer")

    def format_help(self):
        return "outer"

    def _dp_lambda_4():
        return format_help$0
    _dp_lambda_4 = __dp__.update_fn(_dp_lambda_4, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "format_help", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "format_help", _dp_lambda_4), "Outer", "<locals>"))

    def _dp_ns_Inner(_dp_class_ns):

        def _dp_lambda_1():
            return __name__$0
        _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, "Outer", "<lambda>")
        __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
        __dp__.setattr(_dp_class_ns, "__qualname__", "Outer.Inner")

        def format_help(self):
            return getattr$0(time$0.get_clock_info("monotonic"), "resolution")

        def _dp_lambda_2():
            return format_help$0
        _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, "Outer", "<lambda>")
        __dp__.setattr(_dp_class_ns, "format_help", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "format_help", _dp_lambda_2), "Outer.Inner", "<locals>"))
    _dp_ns_Inner = __dp__.update_fn(_dp_ns_Inner, "Outer", "<locals>")
    __dp__.setattr(_dp_class_ns, "Inner", __dp__.create_class("Inner", _dp_ns_Inner, (), None))
Outer = __dp__.create_class("Outer", _dp_ns_Outer, (), None)
VALUE = getattr(Outer.Inner(), "format_help")()

$ asyncio wait_for releases cancelled task locals

import asyncio
import gc
import weakref

class Payload:
    pass

async def hold_ref(ref_holder):
    obj = Payload()
    ref_holder.append(weakref.ref(obj))
    await asyncio.sleep(10)

def leak_check():
    ref_holder = []

    async def runner():
        await asyncio.wait_for(hold_ref(ref_holder), 0.01)

    try:
        asyncio.run(runner())
    except asyncio.TimeoutError:
        pass

    gc.collect()
    return ref_holder[0]()
=
asyncio = __dp__.import_("asyncio", __spec__)
gc = __dp__.import_("gc", __spec__)
weakref = __dp__.import_("weakref", __spec__)
def _dp_ns_Payload(_dp_class_ns):

    def _dp_lambda_1():
        return __name__$0
    _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Payload")
Payload = __dp__.create_class("Payload", _dp_ns_Payload, (), None)
async def hold_ref(ref_holder):
    obj = Payload$0()
    ref_holder.append(weakref$0.ref(obj))
    await asyncio$0.sleep(10)
def leak_check():
    ref_holder = __dp__.list(())

    async def runner():
        await asyncio$0.wait_for(hold_ref$0(ref_holder$1), 0.01)
    try:
        asyncio$0.run(runner())
    except:
        if __dp__.exception_matches(__dp__.current_exception(), asyncio$0.TimeoutError):
            pass
        else:
            raise
    gc$0.collect()
    return __dp__.getitem(ref_holder, 0)()

$ asyncio ssl handshake timeout cleanup

import gc
import importlib
import ssl
import sys
import types
import weakref
from pathlib import Path

ROOT = Path(__file__).resolve().parents[2]
CPYTHON_ASYNCIO = ROOT / "cpython" / "Lib" / "asyncio"
PKG_NAME = "dp_asyncio"
if PKG_NAME not in sys.modules:
    package = types.ModuleType(PKG_NAME)
    package.__path__ = [str(CPYTHON_ASYNCIO)]
    sys.modules[PKG_NAME] = package

base_events = importlib.import_module(f"{PKG_NAME}.base_events")
constants = importlib.import_module(f"{PKG_NAME}.constants")
exceptions = importlib.import_module(f"{PKG_NAME}.exceptions")
protocols = importlib.import_module(f"{PKG_NAME}.protocols")
selector_events = importlib.import_module(f"{PKG_NAME}.selector_events")
sslproto = importlib.import_module(f"{PKG_NAME}.sslproto")
tasks = importlib.import_module(f"{PKG_NAME}.tasks")

class DummySock:
    def setblocking(self, flag):
        pass

class DummyTransport:
    def __init__(self):
        self.closed = False

    def _force_close(self, exc):
        self.closed = True

    def get_extra_info(self, name, default=None):
        return default

    def write(self, data):
        pass

    def is_closing(self):
        return self.closed

    def pause_reading(self):
        pass

    def resume_reading(self):
        pass

    def set_write_buffer_limits(self, high=None, low=None):
        pass

class DummyLoop(selector_events.BaseSelectorEventLoop):
    def _make_ssl_transport(
        self,
        rawsock,
        protocol,
        sslcontext,
        waiter=None,
        *,
        server_side=False,
        server_hostname=None,
        extra=None,
        server=None,
        ssl_handshake_timeout=constants.SSL_HANDSHAKE_TIMEOUT,
        ssl_shutdown_timeout=constants.SSL_SHUTDOWN_TIMEOUT,
    ):
        ssl_protocol = sslproto.SSLProtocol(
            self,
            protocol,
            sslcontext,
            waiter,
            server_side,
            server_hostname,
            ssl_handshake_timeout=ssl_handshake_timeout,
            ssl_shutdown_timeout=ssl_shutdown_timeout,
        )
        ssl_protocol.connection_made(DummyTransport())
        return ssl_protocol._app_transport

    def _make_socket_transport(self, sock, protocol, waiter=None, *, extra=None, server=None):
        return DummyTransport()

def leak_check():
    loop = DummyLoop()
    sslctx = ssl.create_default_context()
    ref = weakref.ref(sslctx)
    sock = DummySock()

    async def run():
        await tasks.wait_for(
            loop._create_connection_transport(
                sock,
                protocols.Protocol,
                sslctx,
                "",
                ssl_handshake_timeout=10.0,
            ),
            0.01,
        )

    try:
        loop.run_until_complete(run())
    except BaseException as exc:
        if exc.__class__.__name__ not in ("TimeoutError", "CancelledError"):
            raise
    finally:
        loop.close()

    sslctx = None
    gc.collect()
    return ref()
=
gc = __dp__.import_("gc", __spec__)
importlib = __dp__.import_("importlib", __spec__)
ssl = __dp__.import_("ssl", __spec__)
sys = __dp__.import_("sys", __spec__)
types = __dp__.import_("types", __spec__)
weakref = __dp__.import_("weakref", __spec__)
_dp_import_1 = __dp__.import_("pathlib", __spec__, __dp__.list(("Path",)))
Path = __dp__.import_attr(_dp_import_1, "Path")
del _dp_import_1
ROOT = __dp__.getitem(getattr(getattr(Path(__file__), "resolve")(), "parents"), 2)
CPYTHON_ASYNCIO = __dp__.truediv(__dp__.truediv(__dp__.truediv(ROOT, "cpython"), "Lib"), "asyncio")
PKG_NAME = "dp_asyncio"
_dp_target_2 = __dp__.not_(__dp__.contains(sys.modules, PKG_NAME))
if _dp_target_2:
    package = types.ModuleType(PKG_NAME)
    __dp__.setattr(package, "__path__", __dp__.list((str(CPYTHON_ASYNCIO),)))
    __dp__.setitem(sys.modules, PKG_NAME, package)
base_events = importlib.import_module(getattr("", "join")((__dp__.builtins.format(PKG_NAME), ".base_events")))
constants = importlib.import_module(getattr("", "join")((__dp__.builtins.format(PKG_NAME), ".constants")))
exceptions = importlib.import_module(getattr("", "join")((__dp__.builtins.format(PKG_NAME), ".exceptions")))
protocols = importlib.import_module(getattr("", "join")((__dp__.builtins.format(PKG_NAME), ".protocols")))
selector_events = importlib.import_module(getattr("", "join")((__dp__.builtins.format(PKG_NAME), ".selector_events")))
sslproto = importlib.import_module(getattr("", "join")((__dp__.builtins.format(PKG_NAME), ".sslproto")))
tasks = importlib.import_module(getattr("", "join")((__dp__.builtins.format(PKG_NAME), ".tasks")))
def _dp_ns_DummySock(_dp_class_ns):

    def _dp_lambda_4():
        return __name__$0
    _dp_lambda_4 = __dp__.update_fn(_dp_lambda_4, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_4))
    __dp__.setattr(_dp_class_ns, "__qualname__", "DummySock")

    def setblocking(self, flag):
        pass

    def _dp_lambda_5():
        return setblocking$0
    _dp_lambda_5 = __dp__.update_fn(_dp_lambda_5, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "setblocking", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "setblocking", _dp_lambda_5), "DummySock", "<locals>"))
DummySock = __dp__.create_class("DummySock", _dp_ns_DummySock, (), None)
def _dp_ns_DummyTransport(_dp_class_ns):

    def _dp_lambda_6():
        return __name__$0
    _dp_lambda_6 = __dp__.update_fn(_dp_lambda_6, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_6))
    __dp__.setattr(_dp_class_ns, "__qualname__", "DummyTransport")

    def __init__(self):
        __dp__.setattr(self, "closed", False)

    def _dp_lambda_7():
        return __init__$0
    _dp_lambda_7 = __dp__.update_fn(_dp_lambda_7, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__init__", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "__init__", _dp_lambda_7), "DummyTransport", "<locals>"))

    def _force_close(self, exc):
        __dp__.setattr(self, "closed", True)

    def _dp_lambda_8():
        return _force_close$0
    _dp_lambda_8 = __dp__.update_fn(_dp_lambda_8, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "_force_close", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "_force_close", _dp_lambda_8), "DummyTransport", "<locals>"))

    def get_extra_info(self, name, default=None):
        return default

    def _dp_lambda_9():
        return get_extra_info$0
    _dp_lambda_9 = __dp__.update_fn(_dp_lambda_9, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "get_extra_info", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "get_extra_info", _dp_lambda_9), "DummyTransport", "<locals>"))

    def write(self, data):
        pass

    def _dp_lambda_10():
        return write$0
    _dp_lambda_10 = __dp__.update_fn(_dp_lambda_10, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "write", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "write", _dp_lambda_10), "DummyTransport", "<locals>"))

    def is_closing(self):
        return self.closed

    def _dp_lambda_11():
        return is_closing$0
    _dp_lambda_11 = __dp__.update_fn(_dp_lambda_11, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "is_closing", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "is_closing", _dp_lambda_11), "DummyTransport", "<locals>"))

    def pause_reading(self):
        pass

    def _dp_lambda_12():
        return pause_reading$0
    _dp_lambda_12 = __dp__.update_fn(_dp_lambda_12, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "pause_reading", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "pause_reading", _dp_lambda_12), "DummyTransport", "<locals>"))

    def resume_reading(self):
        pass

    def _dp_lambda_13():
        return resume_reading$0
    _dp_lambda_13 = __dp__.update_fn(_dp_lambda_13, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "resume_reading", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "resume_reading", _dp_lambda_13), "DummyTransport", "<locals>"))

    def set_write_buffer_limits(self, high=None, low=None):
        pass

    def _dp_lambda_14():
        return set_write_buffer_limits$0
    _dp_lambda_14 = __dp__.update_fn(_dp_lambda_14, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "set_write_buffer_limits", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "set_write_buffer_limits", _dp_lambda_14), "DummyTransport", "<locals>"))
DummyTransport = __dp__.create_class("DummyTransport", _dp_ns_DummyTransport, (), None)
def _dp_ns_DummyLoop(_dp_class_ns):

    def _dp_lambda_15():
        return __name__$0
    _dp_lambda_15 = __dp__.update_fn(_dp_lambda_15, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_15))
    __dp__.setattr(_dp_class_ns, "__qualname__", "DummyLoop")

    def _dp_lambda_16():
        return constants$0
    _dp_lambda_16 = __dp__.update_fn(_dp_lambda_16, None, "<lambda>")

    def _dp_lambda_17():
        return constants$0
    _dp_lambda_17 = __dp__.update_fn(_dp_lambda_17, None, "<lambda>")

    def _make_ssl_transport(self, rawsock, protocol, sslcontext, waiter=None, *, server_side=False, server_hostname=None, extra=None, server=None, ssl_handshake_timeout=getattr$0(__dp__.class_lookup(_dp_class_ns, "constants", _dp_lambda_16), "SSL_HANDSHAKE_TIMEOUT"), ssl_shutdown_timeout=getattr$0(__dp__.class_lookup(_dp_class_ns, "constants", _dp_lambda_17), "SSL_SHUTDOWN_TIMEOUT")):
        ssl_protocol = sslproto$0.SSLProtocol(self, protocol, sslcontext, waiter, server_side, server_hostname, ssl_handshake_timeout=ssl_handshake_timeout, ssl_shutdown_timeout=ssl_shutdown_timeout)
        ssl_protocol.connection_made(DummyTransport$0())
        return ssl_protocol._app_transport

    def _dp_lambda_18():
        return _make_ssl_transport$0
    _dp_lambda_18 = __dp__.update_fn(_dp_lambda_18, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "_make_ssl_transport", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "_make_ssl_transport", _dp_lambda_18), "DummyLoop", "<locals>"))

    def _make_socket_transport(self, sock, protocol, waiter=None, *, extra=None, server=None):
        return DummyTransport$0()

    def _dp_lambda_19():
        return _make_socket_transport$0
    _dp_lambda_19 = __dp__.update_fn(_dp_lambda_19, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "_make_socket_transport", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "_make_socket_transport", _dp_lambda_19), "DummyLoop", "<locals>"))
DummyLoop = __dp__.create_class("DummyLoop", _dp_ns_DummyLoop, (selector_events.BaseSelectorEventLoop,), None)
def leak_check():
    loop = DummyLoop$0()
    sslctx = ssl$0.create_default_context()
    ref = weakref$0.ref(sslctx)
    sock = DummySock$0()

    async def run():
        await tasks$0.wait_for(loop$1._create_connection_transport(sock$1, protocols$0.Protocol, sslctx$1, "", ssl_handshake_timeout=10.0), 0.01)
    try:
        loop.run_until_complete(run())
    except:
        if __dp__.exception_matches(__dp__.current_exception(), BaseException$0):
            exc = __dp__.current_exception()
            try:
                _dp_target_3 = __dp__.not_(__dp__.contains(("TimeoutError", "CancelledError"), exc.__class__.__name__))
                if _dp_target_3:
                    raise
            finally:
                try:
                    del exc
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError$0):
                        pass
                    else:
                        raise
        else:
            raise
    finally:
        loop.close()
    sslctx = None
    gc$0.collect()
    return ref()

$ except star preserves exception groups


def handle():
    exc = None
    try:
        raise ExceptionGroup("eg", [OSError("boom")])
    except* OSError as excs:
        exc = excs
    return exc
=
def handle():
    exc = None
    try:
        raise ExceptionGroup$0("eg", __dp__.list((OSError$0("boom"),)))
    except* OSError$0 as excs:
        exc = excs$0
    return exc

$ except as clears exception binding


import gc
import types

def capture():
    try:
        raise OSError("boom")
    except OSError as err:
        return err

def count_exception_referrer_frames():
    exc = capture()
    refs = [ref for ref in gc.get_referrers(exc) if isinstance(ref, types.FrameType)]
    return len(refs)
=
gc = __dp__.import_("gc", __spec__)
types = __dp__.import_("types", __spec__)
def capture():
    try:
        raise OSError$0("boom")
    except:
        if __dp__.exception_matches(__dp__.current_exception(), OSError$0):
            err = __dp__.current_exception()
            try:
                return err
            finally:
                try:
                    del err
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError$0):
                        pass
                    else:
                        raise
        else:
            raise
def count_exception_referrer_frames():
    exc = capture$0()

    def _dp_gen_1(_dp_iter_2):
        _dp_iter_3 = __dp__.iter(_dp_iter_2)
        try:
            while True:
                ref = __dp__.next(_dp_iter_3)
                if isinstance$0(ref, types$0.FrameType):
                    yield ref
        except:
            if __dp__.exception_matches(__dp__.current_exception(), StopIteration$0):
                pass
            else:
                raise
    _dp_gen_1 = __dp__.update_fn(_dp_gen_1, "count_exception_referrer_frames.<locals>", "<genexpr>")
    refs = __dp__.list(_dp_gen_1(__dp__.iter(gc$0.get_referrers(exc))))
    return len$0(refs)

$ lru cache method pickles with stable qualname


import functools
import pickle

class HasCache:
    @functools.lru_cache()
    def cached_meth(self, x, y):
        return x + y

def pickle_cached_method():
    return pickle.loads(pickle.dumps(HasCache.cached_meth))
=
functools = __dp__.import_("functools", __spec__)
pickle = __dp__.import_("pickle", __spec__)
def _dp_ns_HasCache(_dp_class_ns):

    def _dp_lambda_1():
        return __name__$0
    _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
    __dp__.setattr(_dp_class_ns, "__qualname__", "HasCache")

    def cached_meth(self, x, y):
        return __dp__.add(x, y)

    def _dp_lambda_2():
        return cached_meth$0
    _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "cached_meth", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "cached_meth", _dp_lambda_2), "HasCache", "<locals>"))

    def _dp_lambda_3():
        return cached_meth$0
    _dp_lambda_3 = __dp__.update_fn(_dp_lambda_3, None, "<lambda>")

    def _dp_lambda_4():
        return functools$0
    _dp_lambda_4 = __dp__.update_fn(_dp_lambda_4, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "cached_meth", getattr$0(__dp__.class_lookup(_dp_class_ns, "functools", _dp_lambda_4), "lru_cache")()(__dp__.class_lookup(_dp_class_ns, "cached_meth", _dp_lambda_3)))
HasCache = __dp__.create_class("HasCache", _dp_ns_HasCache, (), None)
def pickle_cached_method():
    return pickle$0.loads(pickle$0.dumps(HasCache$0.cached_meth))

$ positional-only param shadows class attribute


def make_value():
    class Example:
        a = 40

        def compute(self):
            def f(a, b, /):
                return a + b

            return f(1, 2)

    return Example().compute()
=
def make_value():

    def _dp_ns_Example(_dp_class_ns):

        def _dp_lambda_1():
            return __name__$0
        _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, "make_value.<locals>", "<lambda>")
        __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
        __dp__.setattr(_dp_class_ns, "__qualname__", "make_value.<locals>.Example")
        __dp__.setattr(_dp_class_ns, "a", 40)

        def compute(self):

            def f(a, b, /):
                return __dp__.add(a, b)
            return f(1, 2)

        def _dp_lambda_2():
            return compute$0
        _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, "make_value.<locals>", "<lambda>")
        __dp__.setattr(_dp_class_ns, "compute", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "compute", _dp_lambda_2), "make_value.<locals>.Example", "<locals>"))
    Example = __dp__.create_class("Example", _dp_ns_Example, (), None)
    return getattr$0(Example(), "compute")()

$ integration: functools singledispatch qualname

from __future__ import annotations

import functools


class Wrapper:
    def make_nested_class(self):
        class A:
            @functools.singledispatchmethod
            def func(self, arg: int) -> str:
                return str(arg)

        return A

    def bad_register_message(self):
        @functools.singledispatch
        def i(arg):
            return "base"

        try:
            @i.register
            def _(arg):
                return "missing annotation"
        except TypeError as exc:
            return str(exc)

        raise AssertionError("expected TypeError")
=
functools = __dp__.import_("functools", __spec__)
def _dp_ns_Wrapper(_dp_class_ns):

    def _dp_lambda_6():
        return __name__$0
    _dp_lambda_6 = __dp__.update_fn(_dp_lambda_6, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_6))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Wrapper")

    def make_nested_class(self):

        def _dp_ns_A(_dp_class_ns):

            def _dp_lambda_2():
                return __name__$0
            _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, "Wrapper.make_nested_class.<locals>", "<lambda>")
            __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_2))
            __dp__.setattr(_dp_class_ns, "__qualname__", "Wrapper.make_nested_class.<locals>.A")

            def func(self, arg: "int") -> "str":
                return str$0(arg)

            def _dp_lambda_3():
                return func$0
            _dp_lambda_3 = __dp__.update_fn(_dp_lambda_3, "Wrapper.make_nested_class.<locals>", "<lambda>")
            __dp__.setattr(_dp_class_ns, "func", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "func", _dp_lambda_3), "Wrapper.make_nested_class.<locals>.A", "<locals>"))

            def _dp_lambda_4():
                return func$0
            _dp_lambda_4 = __dp__.update_fn(_dp_lambda_4, "Wrapper.make_nested_class.<locals>", "<lambda>")

            def _dp_lambda_5():
                return functools$0
            _dp_lambda_5 = __dp__.update_fn(_dp_lambda_5, "Wrapper.make_nested_class.<locals>", "<lambda>")
            __dp__.setattr(_dp_class_ns, "func", getattr$0(__dp__.class_lookup(_dp_class_ns, "functools", _dp_lambda_5), "singledispatchmethod")(__dp__.class_lookup(_dp_class_ns, "func", _dp_lambda_4)))
        A = __dp__.create_class("A", _dp_ns_A, (), None)
        return A

    def _dp_lambda_7():
        return make_nested_class$0
    _dp_lambda_7 = __dp__.update_fn(_dp_lambda_7, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "make_nested_class", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "make_nested_class", _dp_lambda_7), "Wrapper", "<locals>"))

    def bad_register_message(self):

        def i(arg):
            return "base"
        i = functools$0.singledispatch(i)
        try:

            def _(arg):
                return "missing annotation"
            _ = i.register(_)
        except:
            if __dp__.exception_matches(__dp__.current_exception(), TypeError$0):
                exc = __dp__.current_exception()
                try:
                    return str$0(exc)
                finally:
                    try:
                        del exc
                    except:
                        if __dp__.exception_matches(__dp__.current_exception(), NameError$0):
                            pass
                        else:
                            raise
            else:
                raise
        raise AssertionError$0("expected TypeError")

    def _dp_lambda_8():
        return bad_register_message$0
    _dp_lambda_8 = __dp__.update_fn(_dp_lambda_8, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "bad_register_message", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "bad_register_message", _dp_lambda_8), "Wrapper", "<locals>"))
Wrapper = __dp__.create_class("Wrapper", _dp_ns_Wrapper, (), None)

$ integration: enum dynamic members via vars update

from __future__ import annotations

from enum import Enum


FOO_DEFINES = {
    "FOO_CAT": "aloof",
    "BAR_DOG": "friendly",
    "FOO_HORSE": "big",
}


class Foo(Enum):
    vars().update({
        k: v
        for k, v in FOO_DEFINES.items()
        if k.startswith("FOO_")
    })

    def upper(self):
        return self.value.upper()
=
_dp_import_1 = __dp__.import_("enum", __spec__, __dp__.list(("Enum",)))
Enum = __dp__.import_attr(_dp_import_1, "Enum")
del _dp_import_1
FOO_DEFINES = __dp__.dict((("FOO_CAT", "aloof"), ("BAR_DOG", "friendly"), ("FOO_HORSE", "big")))
def _dp_ns_Foo(_dp_class_ns):

    def _dp_lambda_7():
        return __name__$0
    _dp_lambda_7 = __dp__.update_fn(_dp_lambda_7, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_7))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Foo")

    def _dp_gen_2(_dp_iter_3):
        _dp_iter_4 = __dp__.iter(_dp_iter_3)
        try:
            while True:
                _dp_tmp_5 = __dp__.next(_dp_iter_4)
                try:
                    _dp_tmp_6 = __dp__.unpack(_dp_tmp_5, (True, True))
                    k = __dp__.getitem(_dp_tmp_6, 0)
                    v = __dp__.getitem(_dp_tmp_6, 1)
                finally:
                    _dp_tmp_6 = None
                    _dp_tmp_5 = None
                if k.startswith("FOO_"):
                    yield k, v
        except:
            if __dp__.exception_matches(__dp__.current_exception(), StopIteration$0):
                pass
            else:
                raise
    _dp_gen_2 = __dp__.update_fn(_dp_gen_2, "Foo", "<locals>")
    _dp_gen_2 = __dp__.update_fn(_dp_gen_2, "Foo", "<genexpr>")

    def _dp_lambda_8():
        return getattr$0
    _dp_lambda_8 = __dp__.update_fn(_dp_lambda_8, None, "<lambda>")

    def _dp_lambda_9():
        return FOO_DEFINES$0
    _dp_lambda_9 = __dp__.update_fn(_dp_lambda_9, None, "<lambda>")
    __dp__.class_lookup(_dp_class_ns, "getattr", _dp_lambda_8)(_dp_class_ns._namespace, "update")(__dp__.dict(_dp_gen_2(__dp__.iter(getattr$0(__dp__.class_lookup(_dp_class_ns, "FOO_DEFINES", _dp_lambda_9), "items")()))))

    def upper(self):
        return self.value.upper()

    def _dp_lambda_10():
        return upper$0
    _dp_lambda_10 = __dp__.update_fn(_dp_lambda_10, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "upper", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "upper", _dp_lambda_10), "Foo", "<locals>"))
Foo = __dp__.create_class("Foo", _dp_ns_Foo, (Enum,), None)

$ integration: enum ignore dynamic names

from __future__ import annotations

from enum import Enum


class Period(Enum):
    _ignore_ = "Period i"
    Period = vars()
    for i in range(2):
        Period[f"day_{i}"] = i
    OneDay = day_1
=
_dp_import_1 = __dp__.import_("enum", __spec__, __dp__.list(("Enum",)))
Enum = __dp__.import_attr(_dp_import_1, "Enum")
del _dp_import_1
def _dp_ns_Period(_dp_class_ns):

    def _dp_lambda_3():
        return __name__$0
    _dp_lambda_3 = __dp__.update_fn(_dp_lambda_3, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_3))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Period")
    __dp__.setattr(_dp_class_ns, "_ignore_", "Period i")
    __dp__.setattr(_dp_class_ns, "Period", _dp_class_ns._namespace)

    def _dp_lambda_4():
        return range$0
    _dp_lambda_4 = __dp__.update_fn(_dp_lambda_4, None, "<lambda>")
    _dp_iter_2 = __dp__.iter(__dp__.class_lookup(_dp_class_ns, "range", _dp_lambda_4)(2))
    try:
        while True:
            __dp__.setattr(_dp_class_ns, "i", __dp__.next(_dp_iter_2))

            def _dp_lambda_5():
                return Period$0
            _dp_lambda_5 = __dp__.update_fn(_dp_lambda_5, None, "<lambda>")

            def _dp_lambda_6():
                return getattr$0
            _dp_lambda_6 = __dp__.update_fn(_dp_lambda_6, None, "<lambda>")

            def _dp_lambda_7():
                return i$0
            _dp_lambda_7 = __dp__.update_fn(_dp_lambda_7, None, "<lambda>")

            def _dp_lambda_8():
                return i$0
            _dp_lambda_8 = __dp__.update_fn(_dp_lambda_8, None, "<lambda>")
            __dp__.setitem(__dp__.class_lookup(_dp_class_ns, "Period", _dp_lambda_5), __dp__.class_lookup(_dp_class_ns, "getattr", _dp_lambda_6)("", "join")(("day_", __dp__.builtins.format(__dp__.class_lookup(_dp_class_ns, "i", _dp_lambda_7)))), __dp__.class_lookup(_dp_class_ns, "i", _dp_lambda_8))
    except:

        def _dp_lambda_9():
            return StopIteration$0
        _dp_lambda_9 = __dp__.update_fn(_dp_lambda_9, None, "<lambda>")
        if __dp__.exception_matches(__dp__.current_exception(), __dp__.class_lookup(_dp_class_ns, "StopIteration", _dp_lambda_9)):
            pass
        else:
            raise

    def _dp_lambda_10():
        return day_1$0
    _dp_lambda_10 = __dp__.update_fn(_dp_lambda_10, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "OneDay", __dp__.class_lookup(_dp_class_ns, "day_1", _dp_lambda_10))
Period = __dp__.create_class("Period", _dp_ns_Period, (Enum,), None)

$ integration: enum flag nonmember auto or

from __future__ import annotations

from enum import Flag, auto, nonmember


class Status(Flag):
    A = auto()
    B = auto()
    ALL = nonmember(A | B)


def build_values():
    return Status.A, Status.B, Status.ALL
=
_dp_import_1 = __dp__.import_("enum", __spec__, __dp__.list(("Flag", "auto", "nonmember")))
Flag = __dp__.import_attr(_dp_import_1, "Flag")
auto = __dp__.import_attr(_dp_import_1, "auto")
nonmember = __dp__.import_attr(_dp_import_1, "nonmember")
del _dp_import_1
def _dp_ns_Status(_dp_class_ns):

    def _dp_lambda_2():
        return __name__$0
    _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_2))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Status")

    def _dp_lambda_3():
        return auto$0
    _dp_lambda_3 = __dp__.update_fn(_dp_lambda_3, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "A", __dp__.class_lookup(_dp_class_ns, "auto", _dp_lambda_3)())

    def _dp_lambda_4():
        return auto$0
    _dp_lambda_4 = __dp__.update_fn(_dp_lambda_4, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "B", __dp__.class_lookup(_dp_class_ns, "auto", _dp_lambda_4)())

    def _dp_lambda_5():
        return nonmember$0
    _dp_lambda_5 = __dp__.update_fn(_dp_lambda_5, None, "<lambda>")

    def _dp_lambda_6():
        return A$0
    _dp_lambda_6 = __dp__.update_fn(_dp_lambda_6, None, "<lambda>")

    def _dp_lambda_7():
        return B$0
    _dp_lambda_7 = __dp__.update_fn(_dp_lambda_7, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "ALL", __dp__.class_lookup(_dp_class_ns, "nonmember", _dp_lambda_5)(__dp__.or_(__dp__.class_lookup(_dp_class_ns, "A", _dp_lambda_6), __dp__.class_lookup(_dp_class_ns, "B", _dp_lambda_7))))
Status = __dp__.create_class("Status", _dp_ns_Status, (Flag,), None)
def build_values():
    return Status$0.A, Status$0.B, Status$0.ALL

$ integration: dynamicclassattribute class scope getter

from __future__ import annotations

from types import DynamicClassAttribute


class Base:
    @DynamicClassAttribute
    def spam(self):
        return 1


class Sub(Base):
    spam = Base.__dict__["spam"]

    @spam.getter
    def spam(self):
        return 2


def get_value():
    return Sub().spam
=
_dp_import_1 = __dp__.import_("types", __spec__, __dp__.list(("DynamicClassAttribute",)))
DynamicClassAttribute = __dp__.import_attr(_dp_import_1, "DynamicClassAttribute")
del _dp_import_1
def _dp_ns_Base(_dp_class_ns):

    def _dp_lambda_2():
        return __name__$0
    _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_2))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Base")

    def spam(self):
        return 1

    def _dp_lambda_3():
        return spam$0
    _dp_lambda_3 = __dp__.update_fn(_dp_lambda_3, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "spam", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "spam", _dp_lambda_3), "Base", "<locals>"))

    def _dp_lambda_4():
        return DynamicClassAttribute$0
    _dp_lambda_4 = __dp__.update_fn(_dp_lambda_4, None, "<lambda>")

    def _dp_lambda_5():
        return spam$0
    _dp_lambda_5 = __dp__.update_fn(_dp_lambda_5, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "spam", __dp__.class_lookup(_dp_class_ns, "DynamicClassAttribute", _dp_lambda_4)(__dp__.class_lookup(_dp_class_ns, "spam", _dp_lambda_5)))
Base = __dp__.create_class("Base", _dp_ns_Base, (), None)
def _dp_ns_Sub(_dp_class_ns):

    def _dp_lambda_6():
        return __name__$0
    _dp_lambda_6 = __dp__.update_fn(_dp_lambda_6, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_6))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Sub")

    def _dp_lambda_7():
        return Base$0
    _dp_lambda_7 = __dp__.update_fn(_dp_lambda_7, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "spam", __dp__.getitem(getattr$0(__dp__.class_lookup(_dp_class_ns, "Base", _dp_lambda_7), "__dict__"), "spam"))

    def spam(self):
        return 2

    def _dp_lambda_8():
        return spam$0
    _dp_lambda_8 = __dp__.update_fn(_dp_lambda_8, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "spam", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "spam", _dp_lambda_8), "Sub", "<locals>"))

    def _dp_lambda_9():
        return spam$0
    _dp_lambda_9 = __dp__.update_fn(_dp_lambda_9, None, "<lambda>")

    def _dp_lambda_10():
        return spam$0
    _dp_lambda_10 = __dp__.update_fn(_dp_lambda_10, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "spam", getattr$0(__dp__.class_lookup(_dp_class_ns, "spam", _dp_lambda_10), "getter")(__dp__.class_lookup(_dp_class_ns, "spam", _dp_lambda_9)))
Sub = __dp__.create_class("Sub", _dp_ns_Sub, (Base,), None)
def get_value():
    return getattr$0(Sub$0(), "spam")

$ integration: asyncgen expression async for

from __future__ import annotations

import asyncio


async def arange(n):
    for i in range(n):
        await asyncio.sleep(0)
        yield i


def make_arange(n):
    return (i * 2 async for i in arange(n))


async def run():
    return [i async for i in make_arange(3)]


def get_values():
    return asyncio.run(run())
=
asyncio = __dp__.import_("asyncio", __spec__)
async def arange(n):
    _dp_iter_1 = __dp__.iter(range$0(n))
    try:
        while True:
            i = __dp__.next(_dp_iter_1)
            await asyncio$0.sleep(0)
            yield i
    except:
        if __dp__.exception_matches(__dp__.current_exception(), StopIteration$0):
            pass
        else:
            raise
def make_arange(n):

    async def _dp_gen_5(_dp_iter_6):
        _dp_iter_7 = __dp__.aiter(_dp_iter_6)
        try:
            while True:
                i = await __dp__.anext(_dp_iter_7)
                yield __dp__.mul(i, 2)
        except:
            if __dp__.exception_matches(__dp__.current_exception(), StopAsyncIteration$0):
                pass
            else:
                raise
    _dp_gen_5 = __dp__.update_fn(_dp_gen_5, "make_arange.<locals>", "<genexpr>")
    return _dp_gen_5(arange$0(n))
async def run():

    async def _dp_gen_2(_dp_iter_3):
        _dp_iter_4 = __dp__.aiter(_dp_iter_3)
        try:
            while True:
                i = await __dp__.anext(_dp_iter_4)
                yield i
        except:
            if __dp__.exception_matches(__dp__.current_exception(), StopAsyncIteration$0):
                pass
            else:
                raise
    _dp_gen_2 = __dp__.update_fn(_dp_gen_2, "run.<locals>", "<genexpr>")
    return __dp__.list(_dp_gen_2(make_arange$0(3)))
def get_values():
    return asyncio$0.run(run$0())

$ integration: assert shadowing

from __future__ import annotations


def trigger():
    global AssertionError
    AssertionError = TypeError
    try:
        assert False, "hello"
    except BaseException as exc:
        del AssertionError
        return exc
    else:
        del AssertionError
        raise AssertionError("missing exception")
=
def trigger():
    AssertionError$0 = TypeError$0
    try:
        if __debug__$0:
            if __dp__.not_(False):
                raise __dp__.builtins.AssertionError("hello")
    except:
        if __dp__.exception_matches(__dp__.current_exception(), BaseException$0):
            exc = __dp__.current_exception()
            try:
                del AssertionError$0
                return exc
            finally:
                try:
                    del exc
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError$0):
                        pass
                    else:
                        raise
        else:
            raise
    else:
        del AssertionError$0
        raise AssertionError$0("missing exception")

$ integration: exception cleanup name

from __future__ import annotations


def has_exception_name():
    try:
        1 / 0
    except Exception as e:
        pass
    return "e" in locals()
=
def has_exception_name():
    try:
        __dp__.truediv(1, 0)
    except:
        if __dp__.exception_matches(__dp__.current_exception(), Exception$0):
            e = __dp__.current_exception()
            try:
                pass
            finally:
                try:
                    del e
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError$0):
                        pass
                    else:
                        raise
        else:
            raise
    _dp_target_1 = __dp__.contains(locals$0(), "e")
    return _dp_target_1

$ integration: exception cleanup deleted

def cleanup_deleted():
    try:
        raise Exception()
    except Exception as e:
        del e
    return "e" in locals()


def unbound_after_delete():
    try:
        raise Exception()
    except Exception as e:
        del e
    try:
        e
    except UnboundLocalError:
        return True
    return False
=
def cleanup_deleted():
    try:
        raise Exception$0()
    except:
        if __dp__.exception_matches(__dp__.current_exception(), Exception$0):
            e = __dp__.current_exception()
            try:
                del e
            finally:
                try:
                    del e
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError$0):
                        pass
                    else:
                        raise
        else:
            raise
    _dp_target_1 = __dp__.contains(locals$0(), "e")
    return _dp_target_1
def unbound_after_delete():
    try:
        raise Exception$0()
    except:
        if __dp__.exception_matches(__dp__.current_exception(), Exception$0):
            e = __dp__.current_exception()
            try:
                del e
            finally:
                try:
                    del e
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError$0):
                        pass
                    else:
                        raise
        else:
            raise
    try:
        e
    except:
        if __dp__.exception_matches(__dp__.current_exception(), UnboundLocalError$0):
            return True
        else:
            raise
    return False

$ integration: fstring debug conversion

def format_debug():
    value = "A string"
    return f"{value=}"
=
def format_debug():
    value = "A string"
    return getattr$0("", "join")(("value=", __dp__.builtins.format(__dp__.builtins.repr(value))))

$ integration: ast visit ellipsis

import ast


def visit_ellipsis():
    log = []

    class Visitor(ast.NodeVisitor):
        def visit_Ellipsis(self, node):
            log.append(("Ellipsis", ...))

    mod = ast.parse("e = ...")
    Visitor().visit(mod)
    return log
=
ast = __dp__.import_("ast", __spec__)
def visit_ellipsis():
    log = __dp__.list(())

    def _dp_ns_Visitor(_dp_class_ns):

        def _dp_lambda_1():
            return __name__$0
        _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, "visit_ellipsis.<locals>", "<lambda>")
        __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
        __dp__.setattr(_dp_class_ns, "__qualname__", "visit_ellipsis.<locals>.Visitor")

        def visit_Ellipsis(self, node):
            log$1.append(("Ellipsis", ...))

        def _dp_lambda_2():
            return visit_Ellipsis$0
        _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, "visit_ellipsis.<locals>", "<lambda>")
        __dp__.setattr(_dp_class_ns, "visit_Ellipsis", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "visit_Ellipsis", _dp_lambda_2), "visit_ellipsis.<locals>.Visitor", "<locals>"))
    Visitor = __dp__.create_class("Visitor", _dp_ns_Visitor, (ast$0.NodeVisitor,), None)
    mod = ast$0.parse("e = ...")
    getattr$0(Visitor(), "visit")(mod)
    return log

$ integration: disable transform temp module

import importlib
import sys
import textwrap
from pathlib import Path


def import_without_transform(tmp_path: Path) -> bool:
    module_name = "dp_disable_temp"
    module_path = tmp_path / f"{module_name}.py"
    module_path.write_text(
        textwrap.dedent(
            """\
            # diet-python: disable
            VALUE = 1
            """
        ),
        encoding="utf-8",
    )
    sys.path.insert(0, str(tmp_path))
    try:
        sys.modules.pop(module_name, None)
        module = importlib.import_module(module_name)
        return "__dp__" in module.__dict__
    finally:
        sys.modules.pop(module_name, None)
        if sys.path and sys.path[0] == str(tmp_path):
            sys.path.pop(0)
=
importlib = __dp__.import_("importlib", __spec__)
sys = __dp__.import_("sys", __spec__)
textwrap = __dp__.import_("textwrap", __spec__)
_dp_import_1 = __dp__.import_("pathlib", __spec__, __dp__.list(("Path",)))
Path = __dp__.import_attr(_dp_import_1, "Path")
del _dp_import_1
def import_without_transform(tmp_path: Path$0) -> bool$0:
    module_name = "dp_disable_temp"
    module_path = __dp__.truediv(tmp_path, getattr$0("", "join")((__dp__.builtins.format(module_name), ".py")))
    module_path.write_text(textwrap$0.dedent("""            # diet-python: disable\n            VALUE = 1\n            """), encoding="utf-8")
    sys$0.path.insert(0, str$0(tmp_path))
    try:
        sys$0.modules.pop(module_name, None)
        module = importlib$0.import_module(module_name)
        _dp_target_2 = __dp__.contains(module.__dict__, "__dp__")
        return _dp_target_2
    finally:
        sys$0.modules.pop(module_name, None)
        _dp_target_3 = sys$0.path
        if _dp_target_3:
            _dp_target_4 = __dp__.eq(__dp__.getitem(sys$0.path, 0), str$0(tmp_path))
            _dp_target_3 = _dp_target_4
        if _dp_target_3:
            sys$0.path.pop(0)

$ integration: skip outside repo transform

import importlib
import sys
from pathlib import Path


def imported_without_transform(tmp_path: Path) -> bool:
    module_name = "dp_outside_repo"
    module_path = tmp_path / f"{module_name}.py"
    module_path.write_text("VALUE = 1\n", encoding="utf-8")
    sys.path.insert(0, str(tmp_path))
    try:
        sys.modules.pop(module_name, None)
        module = importlib.import_module(module_name)
        return "__dp__" in module.__dict__
    finally:
        sys.modules.pop(module_name, None)
        if sys.path and sys.path[0] == str(tmp_path):
            sys.path.pop(0)
=
importlib = __dp__.import_("importlib", __spec__)
sys = __dp__.import_("sys", __spec__)
_dp_import_1 = __dp__.import_("pathlib", __spec__, __dp__.list(("Path",)))
Path = __dp__.import_attr(_dp_import_1, "Path")
del _dp_import_1
def imported_without_transform(tmp_path: Path$0) -> bool$0:
    module_name = "dp_outside_repo"
    module_path = __dp__.truediv(tmp_path, getattr$0("", "join")((__dp__.builtins.format(module_name), ".py")))
    module_path.write_text("VALUE = 1\n", encoding="utf-8")
    sys$0.path.insert(0, str$0(tmp_path))
    try:
        sys$0.modules.pop(module_name, None)
        module = importlib$0.import_module(module_name)
        _dp_target_2 = __dp__.contains(module.__dict__, "__dp__")
        return _dp_target_2
    finally:
        sys$0.modules.pop(module_name, None)
        _dp_target_3 = sys$0.path
        if _dp_target_3:
            _dp_target_4 = __dp__.eq(__dp__.getitem(sys$0.path, 0), str$0(tmp_path))
            _dp_target_3 = _dp_target_4
        if _dp_target_3:
            sys$0.path.pop(0)

$ integration: strip internal traceback

from pathlib import Path


def traceback_files():
    try:
        import nonexistent_xyzzy
    except ImportError as exc:
        tb = exc.__traceback__
        files = []
        while tb:
            files.append(Path(tb.tb_frame.f_code.co_filename).name)
            tb = tb.tb_next
        return files
    return []
=
_dp_import_1 = __dp__.import_("pathlib", __spec__, __dp__.list(("Path",)))
Path = __dp__.import_attr(_dp_import_1, "Path")
del _dp_import_1
def traceback_files():
    try:
        nonexistent_xyzzy = __dp__.import_("nonexistent_xyzzy", __spec__$0)
    except:
        if __dp__.exception_matches(__dp__.current_exception(), ImportError$0):
            exc = __dp__.current_exception()
            try:
                tb = exc.__traceback__
                files = __dp__.list(())
                _dp_test_flag_2 = True
                while True:
                    _dp_test_flag_2 = tb
                    if __dp__.not_(_dp_test_flag_2):
                        break
                    files.append(getattr$0(Path$0(tb.tb_frame.f_code.co_filename), "name"))
                    tb = tb.tb_next
                if _dp_test_flag_2:
                    pass
                return files
            finally:
                try:
                    del exc
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError$0):
                        pass
                    else:
                        raise
        else:
            raise
    return __dp__.list(())

$ integration: dotted import alias rebind

import sys
from pathlib import Path


def alias_rebind_attrs(tmp_path: Path) -> tuple[str, str]:
    package_name = "dp_alias_pkg"
    package_dir = tmp_path / package_name
    package_dir.mkdir()
    init_path = package_dir / "__init__.py"
    init_path.write_text("from .submodule import submodule\n", encoding="utf-8")
    submodule_path = package_dir / "submodule.py"
    submodule_path.write_text(
        "attr = 'submodule'\nclass submodule:\n    attr = 'rebound'\n",
        encoding="utf-8",
    )
    sys.path.insert(0, str(tmp_path))
    try:
        sys.modules.pop(package_name, None)
        sys.modules.pop(f"{package_name}.submodule", None)
        from dp_alias_pkg import submodule as from_import
        import dp_alias_pkg.submodule as direct_import
        return from_import.attr, direct_import.attr
    finally:
        sys.modules.pop(package_name, None)
        sys.modules.pop(f"{package_name}.submodule", None)
        if sys.path and sys.path[0] == str(tmp_path):
            sys.path.pop(0)
=
sys = __dp__.import_("sys", __spec__)
_dp_import_1 = __dp__.import_("pathlib", __spec__, __dp__.list(("Path",)))
Path = __dp__.import_attr(_dp_import_1, "Path")
del _dp_import_1
def alias_rebind_attrs(tmp_path: Path$0) -> __dp__.getitem(tuple$0, (str$0, str$0)):
    package_name = "dp_alias_pkg"
    package_dir = __dp__.truediv(tmp_path, package_name)
    package_dir.mkdir()
    init_path = __dp__.truediv(package_dir, "__init__.py")
    init_path.write_text("from .submodule import submodule\n", encoding="utf-8")
    submodule_path = __dp__.truediv(package_dir, "submodule.py")
    submodule_path.write_text("attr = 'submodule'\nclass submodule:\n    attr = 'rebound'\n", encoding="utf-8")
    sys$0.path.insert(0, str$0(tmp_path))
    try:
        sys$0.modules.pop(package_name, None)
        sys$0.modules.pop(getattr$0("", "join")((__dp__.builtins.format(package_name), ".submodule")), None)
        _dp_import_2 = __dp__.import_("dp_alias_pkg", __spec__$0, __dp__.list(("submodule",)))
        from_import = __dp__.import_attr(_dp_import_2, "submodule")
        del _dp_import_2
        direct_import = __dp__.import_attr(__dp__.import_("dp_alias_pkg.submodule", __spec__$0), "submodule")
        return from_import.attr, direct_import.attr
    finally:
        sys$0.modules.pop(package_name, None)
        sys$0.modules.pop(getattr$0("", "join")((__dp__.builtins.format(package_name), ".submodule")), None)
        _dp_target_3 = sys$0.path
        if _dp_target_3:
            _dp_target_4 = __dp__.eq(__dp__.getitem(sys$0.path, 0), str$0(tmp_path))
            _dp_target_3 = _dp_target_4
        if _dp_target_3:
            sys$0.path.pop(0)

$ integration: meta path pathfinder preserved

import importlib
import sys
import textwrap
from pathlib import Path
from tempfile import TemporaryDirectory

import diet_import_hook


def import_with_filtered_meta_path() -> bool:
    diet_import_hook.install()
    original_meta_path = list(sys.meta_path)
    try:
        sys.meta_path[:] = [
            item for item in sys.meta_path if item.__module__.startswith("_frozen_importlib")
        ]
        with TemporaryDirectory() as tmp_dir:
            tmp_path = Path(tmp_dir)
            module_name = "dp_meta_path_temp"
            module_path = tmp_path / f"{module_name}.py"
            module_path.write_text(
                textwrap.dedent(
                    """\
                    # diet-python: disable
                    VALUE = 1
                    """
                ),
                encoding="utf-8",
            )
            sys.path.insert(0, str(tmp_path))
            try:
                sys.modules.pop(module_name, None)
                importlib.import_module(module_name)
                return True
            finally:
                sys.modules.pop(module_name, None)
                if sys.path and sys.path[0] == str(tmp_path):
                    sys.path.pop(0)
    except ModuleNotFoundError:
        return False
    finally:
        sys.meta_path[:] = original_meta_path
=
importlib = __dp__.import_("importlib", __spec__)
sys = __dp__.import_("sys", __spec__)
textwrap = __dp__.import_("textwrap", __spec__)
_dp_import_1 = __dp__.import_("pathlib", __spec__, __dp__.list(("Path",)))
Path = __dp__.import_attr(_dp_import_1, "Path")
del _dp_import_1
_dp_import_2 = __dp__.import_("tempfile", __spec__, __dp__.list(("TemporaryDirectory",)))
TemporaryDirectory = __dp__.import_attr(_dp_import_2, "TemporaryDirectory")
del _dp_import_2
diet_import_hook = __dp__.import_("diet_import_hook", __spec__)
def import_with_filtered_meta_path() -> bool$0:
    diet_import_hook$0.install()
    original_meta_path = list$0(sys$0.meta_path)
    try:

        def _dp_gen_3(_dp_iter_4):
            _dp_iter_5 = __dp__.iter(_dp_iter_4)
            try:
                while True:
                    item = __dp__.next(_dp_iter_5)
                    if item.__module__.startswith("_frozen_importlib"):
                        yield item
            except:
                if __dp__.exception_matches(__dp__.current_exception(), StopIteration$0):
                    pass
                else:
                    raise
        _dp_gen_3 = __dp__.update_fn(_dp_gen_3, "import_with_filtered_meta_path.<locals>", "<genexpr>")
        __dp__.setitem(sys$0.meta_path, __dp__.slice(None, None, None), __dp__.list(_dp_gen_3(__dp__.iter(sys$0.meta_path))))
        _dp_tmp_7 = __dp__.with_enter(TemporaryDirectory$0())
        try:
            _dp_tmp_8 = __dp__.unpack(_dp_tmp_7, (True, True))
            tmp_dir = __dp__.getitem(_dp_tmp_8, 0)
            _dp_with_exit_6 = __dp__.getitem(_dp_tmp_8, 1)
        finally:
            _dp_tmp_8 = None
            _dp_tmp_7 = None
        try:
            tmp_path = Path$0(tmp_dir)
            module_name = "dp_meta_path_temp"
            module_path = __dp__.truediv(tmp_path, getattr$0("", "join")((__dp__.builtins.format(module_name), ".py")))
            module_path.write_text(textwrap$0.dedent("""                    # diet-python: disable\n                    VALUE = 1\n                    """), encoding="utf-8")
            sys$0.path.insert(0, str$0(tmp_path))
            try:
                sys$0.modules.pop(module_name, None)
                importlib$0.import_module(module_name)
                return True
            finally:
                sys$0.modules.pop(module_name, None)
                _dp_target_9 = sys$0.path
                if _dp_target_9:
                    _dp_target_10 = __dp__.eq(__dp__.getitem(sys$0.path, 0), str$0(tmp_path))
                    _dp_target_9 = _dp_target_10
                if _dp_target_9:
                    sys$0.path.pop(0)
        except:
            __dp__.with_exit(_dp_with_exit_6, __dp__.exc_info())
        else:
            __dp__.with_exit(_dp_with_exit_6, None)
        finally:
            _dp_with_exit_6 = None
    except:
        if __dp__.exception_matches(__dp__.current_exception(), ModuleNotFoundError$0):
            return False
        else:
            raise
    finally:
        __dp__.setitem(sys$0.meta_path, __dp__.slice(None, None, None), original_meta_path)

$ integration: with class mock calls

from unittest import mock


class Context:
    __enter__ = mock.MagicMock(return_value="value")
    __exit__ = mock.MagicMock(return_value=False)


def run():
    Context.__enter__.reset_mock()
    Context.__exit__.reset_mock()
    with Context():
        pass
    return Context.__enter__.mock_calls, Context.__exit__.mock_calls
=
_dp_import_1 = __dp__.import_("unittest", __spec__, __dp__.list(("mock",)))
mock = __dp__.import_attr(_dp_import_1, "mock")
del _dp_import_1
def _dp_ns_Context(_dp_class_ns):

    def _dp_lambda_5():
        return __name__$0
    _dp_lambda_5 = __dp__.update_fn(_dp_lambda_5, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_5))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Context")

    def _dp_lambda_6():
        return mock$0
    _dp_lambda_6 = __dp__.update_fn(_dp_lambda_6, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__enter__", getattr$0(__dp__.class_lookup(_dp_class_ns, "mock", _dp_lambda_6), "MagicMock")(return_value="value"))

    def _dp_lambda_7():
        return mock$0
    _dp_lambda_7 = __dp__.update_fn(_dp_lambda_7, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__exit__", getattr$0(__dp__.class_lookup(_dp_class_ns, "mock", _dp_lambda_7), "MagicMock")(return_value=False))
Context = __dp__.create_class("Context", _dp_ns_Context, (), None)
def run():
    Context$0.__enter__.reset_mock()
    Context$0.__exit__.reset_mock()
    _dp_tmp_3 = __dp__.with_enter(Context$0())
    try:
        _dp_tmp_4 = __dp__.unpack(_dp_tmp_3, (True, True))
        _ = __dp__.getitem(_dp_tmp_4, 0)
        _dp_with_exit_2 = __dp__.getitem(_dp_tmp_4, 1)
    finally:
        _dp_tmp_4 = None
        _dp_tmp_3 = None
    try:
        pass
    except:
        __dp__.with_exit(_dp_with_exit_2, __dp__.exc_info())
    else:
        __dp__.with_exit(_dp_with_exit_2, None)
    finally:
        _dp_with_exit_2 = None
    return Context$0.__enter__.mock_calls, Context$0.__exit__.mock_calls

$ integration: exception refcycle after except

import gc


def run():
    exc = None
    try:
        raise RuntimeError("boom")
    except RuntimeError as e:
        exc = e
    return gc.get_referrers(exc)
=
gc = __dp__.import_("gc", __spec__)
def run():
    exc = None
    try:
        raise RuntimeError$0("boom")
    except:
        if __dp__.exception_matches(__dp__.current_exception(), RuntimeError$0):
            e = __dp__.current_exception()
            try:
                exc = e
            finally:
                try:
                    del e
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError$0):
                        pass
                    else:
                        raise
        else:
            raise
    return gc$0.get_referrers(exc)

$ integration: taskgroup propagate cancellation refcycle

import asyncio
import gc


def run():
    exc = None
    try:
        try:
            raise asyncio.CancelledError()
        except asyncio.CancelledError as err:
            raise TimeoutError from err
    except TimeoutError as err:
        exc = err.__cause__
    return gc.get_referrers(exc)
=
asyncio = __dp__.import_("asyncio", __spec__)
gc = __dp__.import_("gc", __spec__)
def run():
    exc = None
    try:
        try:
            raise asyncio$0.CancelledError()
        except:
            if __dp__.exception_matches(__dp__.current_exception(), asyncio$0.CancelledError):
                err = __dp__.current_exception()
                try:
                    raise __dp__.raise_from(TimeoutError$0, err)
                finally:
                    try:
                        del err
                    except:
                        if __dp__.exception_matches(__dp__.current_exception(), NameError$0):
                            pass
                        else:
                            raise
            else:
                raise
    except:
        if __dp__.exception_matches(__dp__.current_exception(), TimeoutError$0):
            err = __dp__.current_exception()
            try:
                exc = err.__cause__
            finally:
                try:
                    del err
                except:
                    if __dp__.exception_matches(__dp__.current_exception(), NameError$0):
                        pass
                    else:
                        raise
        else:
            raise
    return gc$0.get_referrers(exc)

$ integration: traceback preserves comments

import traceback


def run():
    try:
        1 / 0  # search target
    except ZeroDivisionError:
        return traceback.format_exc()
=
traceback = __dp__.import_("traceback", __spec__)
def run():
    try:
        __dp__.truediv(1, 0)
    except:
        if __dp__.exception_matches(__dp__.current_exception(), ZeroDivisionError$0):
            return traceback$0.format_exc()
        else:
            raise

$ integration: traceback linecache clear

import contextlib
import io
import linecache
import sys


class Reporter:
    def run(self):
        try:
            exc = ValueError("boom")
            raise exc
        except ValueError:
            linecache.clearcache()
            buffer = io.StringIO()
            with contextlib.redirect_stderr(buffer):
                sys.__excepthook__(*sys.exc_info())
            return buffer.getvalue()


def get_report():
    return Reporter().run()
=
contextlib = __dp__.import_("contextlib", __spec__)
io = __dp__.import_("io", __spec__)
linecache = __dp__.import_("linecache", __spec__)
sys = __dp__.import_("sys", __spec__)
def _dp_ns_Reporter(_dp_class_ns):

    def _dp_lambda_4():
        return __name__$0
    _dp_lambda_4 = __dp__.update_fn(_dp_lambda_4, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_4))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Reporter")

    def run(self):
        try:
            exc = ValueError$0("boom")
            raise exc
        except:
            if __dp__.exception_matches(__dp__.current_exception(), ValueError$0):
                linecache$0.clearcache()
                buffer = io$0.StringIO()
                _dp_tmp_2 = __dp__.with_enter(contextlib$0.redirect_stderr(buffer))
                try:
                    _dp_tmp_3 = __dp__.unpack(_dp_tmp_2, (True, True))
                    _ = __dp__.getitem(_dp_tmp_3, 0)
                    _dp_with_exit_1 = __dp__.getitem(_dp_tmp_3, 1)
                finally:
                    _dp_tmp_3 = None
                    _dp_tmp_2 = None
                try:
                    sys$0.__excepthook__(*sys$0.exc_info())
                except:
                    __dp__.with_exit(_dp_with_exit_1, __dp__.exc_info())
                else:
                    __dp__.with_exit(_dp_with_exit_1, None)
                finally:
                    _dp_with_exit_1 = None
                return buffer.getvalue()
            else:
                raise

    def _dp_lambda_5():
        return run$0
    _dp_lambda_5 = __dp__.update_fn(_dp_lambda_5, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "run", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "run", _dp_lambda_5), "Reporter", "<locals>"))
Reporter = __dp__.create_class("Reporter", _dp_ns_Reporter, (), None)
def get_report():
    return getattr$0(Reporter$0(), "run")()

$ integration: surrogate unicode escape repr

def repr_value():
    char = "\uDCBA"
    return repr(char)


def ascii_value():
    char = "\uDCBA"
    return ascii(char)
=
def repr_value():
    char = ""
    return repr$0(char)
def ascii_value():
    char = ""
    return ascii$0(char)

$ integration: lambda qualname

def global_function():
    return (lambda: None).__qualname__, (lambda: None).__name__
=
def global_function():

    def _dp_lambda_1():
        return None
    _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, "global_function.<locals>", "<lambda>")

    def _dp_lambda_2():
        return None
    _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, "global_function.<locals>", "<lambda>")
    return getattr$0(_dp_lambda_1, "__qualname__"), getattr$0(_dp_lambda_2, "__name__")

$ integration: global inner function qualname

def build_qualnames():
    def global_function():
        def inner_function():
            global inner_global_function

            def inner_global_function():
                def inner_function2():
                    pass

                return inner_function2

            return inner_global_function

        return inner_function()

    inner_fn = global_function()
    return inner_global_function.__qualname__, inner_fn().__qualname__

RESULT = build_qualnames()
=
def build_qualnames():

    def global_function():

        def inner_function():

            def inner_global_function():

                def inner_function2():
                    pass
                return inner_function2
            return inner_global_function$0
        return inner_function()
    inner_fn = global_function()
    return inner_global_function$0.__qualname__, getattr$0(inner_fn(), "__qualname__")
RESULT = build_qualnames()

$ integration: coroutine origin tracking line

import sys

sys.set_coroutine_origin_tracking_depth(1)


async def corofn():
    return 1


def a1():
    return corofn()  # comment in a1


def get_origin():
    coro = a1()
    origin = coro.cr_origin
    coro.close()
    return origin


RESULT = get_origin()
=
sys = __dp__.import_("sys", __spec__)
sys.set_coroutine_origin_tracking_depth(1)
async def corofn():
    return 1
def a1():
    return corofn$0()
def get_origin():
    coro = a1$0()
    origin = coro.cr_origin
    coro.close()
    return origin
RESULT = get_origin()

$ integration: reprlib type params

class My:
    def __repr__[T: str](self, default: T = "") -> str:
        return default


def run():
    return My().__repr__()


RESULT = run()
=
def _dp_ns_My(_dp_class_ns):

    def _dp_lambda_1():
        return __name__$0
    _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
    __dp__.setattr(_dp_class_ns, "__qualname__", "My")

    def _dp_lambda_2():
        return str$0
    _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, None, "<lambda>")

    def _dp_lambda_3():
        return str$0
    _dp_lambda_3 = __dp__.update_fn(_dp_lambda_3, None, "<lambda>")

    def __repr__[T: __dp__.class_lookup(_dp_class_ns, "str", _dp_lambda_2)](self, default: T$0="") -> __dp__.class_lookup(_dp_class_ns, "str", _dp_lambda_3):
        return default

    def _dp_lambda_4():
        return __repr__$0
    _dp_lambda_4 = __dp__.update_fn(_dp_lambda_4, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__repr__", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "__repr__", _dp_lambda_4), "My", "<locals>"))
My = __dp__.create_class("My", _dp_ns_My, (), None)
def run():
    return getattr$0(My$0(), "__repr__")()
RESULT = run()

$ integration: iter refcount behavior

import gc


class C:
    count = 0

    def __new__(cls):
        cls.count += 1
        return object.__new__(cls)

    def __del__(self):
        cls = self.__class__
        cls.count -= 1


def run():
    l = [C(), C(), C()]
    try:
        a, b = iter(l)
    except ValueError:
        pass
    del l
    gc.collect()
    return C.count


RESULT = run()
=
gc = __dp__.import_("gc", __spec__)
def _dp_ns_C(_dp_class_ns):

    def _dp_lambda_3():
        return __name__$0
    _dp_lambda_3 = __dp__.update_fn(_dp_lambda_3, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_3))
    __dp__.setattr(_dp_class_ns, "__qualname__", "C")
    __dp__.setattr(_dp_class_ns, "count", 0)

    def __new__(cls):
        __dp__.setattr(cls, "count", __dp__.iadd(cls.count, 1))
        return object$0.__new__(cls)

    def _dp_lambda_4():
        return __new__$0
    _dp_lambda_4 = __dp__.update_fn(_dp_lambda_4, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__new__", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "__new__", _dp_lambda_4), "C", "<locals>"))

    def __del__(self):
        cls = self.__class__
        __dp__.setattr(cls, "count", __dp__.isub(cls.count, 1))

    def _dp_lambda_5():
        return __del__$0
    _dp_lambda_5 = __dp__.update_fn(_dp_lambda_5, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__del__", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "__del__", _dp_lambda_5), "C", "<locals>"))
C = __dp__.create_class("C", _dp_ns_C, (), None)
def run():
    l = __dp__.list((C$0(), C$0(), C$0()))
    try:
        _dp_tmp_1 = iter$0(l)
        try:
            _dp_tmp_2 = __dp__.unpack(_dp_tmp_1, (True, True))
            a = __dp__.getitem(_dp_tmp_2, 0)
            b = __dp__.getitem(_dp_tmp_2, 1)
        finally:
            _dp_tmp_2 = None
            _dp_tmp_1 = None
    except:
        if __dp__.exception_matches(__dp__.current_exception(), ValueError$0):
            pass
        else:
            raise
    del l
    gc$0.collect()
    return C$0.count
RESULT = run()

$ integration: eval_source yield from

def f():
    yield from g()
=
def f():
    yield from g$0()

$ integration: yield from stack names

import sys


def get_stack_names():

    def f():
        frame = sys._getframe()
        yield frame.f_code.co_name, frame.f_back.f_code.co_name

    def g():
        yield from f()

    gen = g()
    return gen.send(None)
=
sys = __dp__.import_("sys", __spec__)
def get_stack_names():

    def f():
        frame = sys$0._getframe()
        yield frame.f_code.co_name, frame.f_back.f_code.co_name

    def g():
        yield from f$1()
    gen = g()
    return gen.send(None)

$ integration: yield from gi_yieldfrom

def get_yieldfrom_name():

    def a():
        yield

    def b():
        yield from a()
        yield
    gen_b = b()
    gen_b.send(None)
    return gen_b.gi_yieldfrom.gi_code.co_name
=
def get_yieldfrom_name():

    def a():
        yield

    def b():
        yield from a$1()
        yield
    gen_b = b()
    gen_b.send(None)
    return gen_b.gi_yieldfrom.gi_code.co_name

$ integration: genexpr name

def get_genexpr_name():
    gen = (i for i in ())
    return gen.__name__
=
def get_genexpr_name():

    def _dp_gen_1(_dp_iter_2):
        _dp_iter_3 = __dp__.iter(_dp_iter_2)
        try:
            while True:
                i = __dp__.next(_dp_iter_3)
                yield i
        except:
            if __dp__.exception_matches(__dp__.current_exception(), StopIteration$0):
                pass
            else:
                raise
    _dp_gen_1 = __dp__.update_fn(_dp_gen_1, "get_genexpr_name.<locals>", "<genexpr>")
    gen = _dp_gen_1(__dp__.iter(()))
    return gen.__name__

$ integration: nested class base

class Outer:
    class BaseThing(str):
        pass

    class Thing(BaseThing):
        pass


def get_base_name():
    return Outer.Thing.__bases__[0].__name__
=
def _dp_ns_Outer(_dp_class_ns):

    def _dp_lambda_5():
        return __name__$0
    _dp_lambda_5 = __dp__.update_fn(_dp_lambda_5, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_5))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Outer")

    def _dp_ns_BaseThing(_dp_class_ns):

        def _dp_lambda_1():
            return __name__$0
        _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, "Outer", "<lambda>")
        __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
        __dp__.setattr(_dp_class_ns, "__qualname__", "Outer.BaseThing")
    _dp_ns_BaseThing = __dp__.update_fn(_dp_ns_BaseThing, "Outer", "<locals>")

    def _dp_lambda_2():
        return str$0
    _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, "Outer", "<locals>")
    _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, "Outer", "<lambda>")
    __dp__.setattr(_dp_class_ns, "BaseThing", __dp__.create_class("BaseThing", _dp_ns_BaseThing, (__dp__.class_lookup(_dp_class_ns, "str", _dp_lambda_2),), None))

    def _dp_ns_Thing(_dp_class_ns):

        def _dp_lambda_3():
            return __name__$0
        _dp_lambda_3 = __dp__.update_fn(_dp_lambda_3, "Outer", "<lambda>")
        __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_3))
        __dp__.setattr(_dp_class_ns, "__qualname__", "Outer.Thing")
    _dp_ns_Thing = __dp__.update_fn(_dp_ns_Thing, "Outer", "<locals>")

    def _dp_lambda_4():
        return BaseThing$0
    _dp_lambda_4 = __dp__.update_fn(_dp_lambda_4, "Outer", "<locals>")
    _dp_lambda_4 = __dp__.update_fn(_dp_lambda_4, "Outer", "<lambda>")
    __dp__.setattr(_dp_class_ns, "Thing", __dp__.create_class("Thing", _dp_ns_Thing, (__dp__.class_lookup(_dp_class_ns, "BaseThing", _dp_lambda_4),), None))
Outer = __dp__.create_class("Outer", _dp_ns_Outer, (), None)
def get_base_name():
    return getattr$0(__dp__.getitem(Outer$0.Thing.__bases__, 0), "__name__")

$ integration: future import invalid feature

from __future__ import not_a_feature

VALUE = 1
=
from __future__ import not_a_feature
VALUE = 1

$ integration: typevar tuple default none

class A[*Ts]:
    pass
=
def _dp_ns_A(_dp_class_ns):
    Ts = __dp__.type_param_typevar_tuple("Ts", None)

    def _dp_lambda_1():
        return __name__$0
    _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
    __dp__.setattr(_dp_class_ns, "__qualname__", "A")
    __dp__.setattr(_dp_class_ns, "__type_params__", (Ts,))
A = __dp__.create_class("A", _dp_ns_A, (__dp__.getitem(getattr(__import__("typing"), "Generic"), __dp__.getitem(getattr(__import__("typing"), "Unpack"), Ts)),), None)

$ integration: io.open class attr

import io


class Reader:
    open = io.open


def read_self():
    with Reader().open(__file__, "rb") as handle:
        return handle.read(1)


RESULT = read_self()
=
io = __dp__.import_("io", __spec__)
def _dp_ns_Reader(_dp_class_ns):

    def _dp_lambda_4():
        return __name__$0
    _dp_lambda_4 = __dp__.update_fn(_dp_lambda_4, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_4))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Reader")

    def _dp_lambda_5():
        return io$0
    _dp_lambda_5 = __dp__.update_fn(_dp_lambda_5, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "open", getattr$0(__dp__.class_lookup(_dp_class_ns, "io", _dp_lambda_5), "open"))
Reader = __dp__.create_class("Reader", _dp_ns_Reader, (), None)
def read_self():
    _dp_tmp_2 = __dp__.with_enter(getattr$0(Reader$0(), "open")(__file__$0, "rb"))
    try:
        _dp_tmp_3 = __dp__.unpack(_dp_tmp_2, (True, True))
        handle = __dp__.getitem(_dp_tmp_3, 0)
        _dp_with_exit_1 = __dp__.getitem(_dp_tmp_3, 1)
    finally:
        _dp_tmp_3 = None
        _dp_tmp_2 = None
    try:
        return handle.read(1)
    except:
        __dp__.with_exit(_dp_with_exit_1, __dp__.exc_info())
    else:
        __dp__.with_exit(_dp_with_exit_1, None)
    finally:
        _dp_with_exit_1 = None
RESULT = read_self()

$ integration: class kwarg metaclass expansion

class Meta(int):
    def __init__(*args, **kwargs):
        pass

    def __new__(cls, name, bases, attrs, **kwargs):
        return bases, kwargs


d = {"metaclass": Meta}


class A(**d):
    pass


RESULT = A
=
def _dp_ns_Meta(_dp_class_ns):

    def _dp_lambda_1():
        return __name__$0
    _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Meta")

    def __init__(*args, **kwargs):
        pass

    def _dp_lambda_2():
        return __init__$0
    _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__init__", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "__init__", _dp_lambda_2), "Meta", "<locals>"))

    def __new__(cls, name, bases, attrs, **kwargs):
        return bases, kwargs

    def _dp_lambda_3():
        return __new__$0
    _dp_lambda_3 = __dp__.update_fn(_dp_lambda_3, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__new__", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "__new__", _dp_lambda_3), "Meta", "<locals>"))
Meta = __dp__.create_class("Meta", _dp_ns_Meta, (int,), None)
d = __dp__.dict((("metaclass", Meta),))
def _dp_ns_A(_dp_class_ns):

    def _dp_lambda_4():
        return __name__$0
    _dp_lambda_4 = __dp__.update_fn(_dp_lambda_4, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_4))
    __dp__.setattr(_dp_class_ns, "__qualname__", "A")
A = __dp__.create_class("A", _dp_ns_A, (), __dp__.dict(d))
RESULT = A

$ integration: for else continue

def collect_for_else_continue():
    seen = []
    for outer in range(3):
        for _inner in []:
            seen.append((_inner, outer))
        else:
            seen.append(outer)
            continue
        seen.append("unreachable")
    return seen


RESULT = collect_for_else_continue()
=
def collect_for_else_continue():
    seen = __dp__.list(())
    _dp_iter_1 = __dp__.iter(range$0(3))
    try:
        while True:
            outer = __dp__.next(_dp_iter_1)
            _dp_iter_2 = __dp__.iter(__dp__.list(()))
            try:
                while True:
                    _inner = __dp__.next(_dp_iter_2)
                    seen.append((_inner, outer))
                seen.append(outer)
                continue
            except:
                if __dp__.exception_matches(__dp__.current_exception(), StopIteration$0):
                    pass
                else:
                    raise
            seen.append("unreachable")
    except:
        if __dp__.exception_matches(__dp__.current_exception(), StopIteration$0):
            pass
        else:
            raise
    return seen
RESULT = collect_for_else_continue()

$ integration: raise from import shadow

import builtins
import sys
import types


def raise_from_with_import_patch():
    package = types.ModuleType("package")

    def _import(name, *args, **kwargs):
        sys.modules[name] = package
        return package

    original_import = builtins.__import__
    builtins.__import__ = _import
    try:
        try:
            raise ValueError("boom")
        except ValueError as exc:
            raise RuntimeError("wrapped") from exc
    except RuntimeError:
        pass
    finally:
        builtins.__import__ = original_import
    return sys.modules.get("asyncio") is package


ASYNCIO_SHADOWED = raise_from_with_import_patch()
=
builtins = __dp__.import_("builtins", __spec__)
sys = __dp__.import_("sys", __spec__)
types = __dp__.import_("types", __spec__)
def raise_from_with_import_patch():
    package = types$0.ModuleType("package")

    def _import(name, *args, **kwargs):
        __dp__.setitem(sys$0.modules, name, package$1)
        return package$1
    original_import = builtins$0.__import__
    __dp__.setattr(builtins$0, "__import__", _import)
    try:
        try:
            raise ValueError$0("boom")
        except:
            if __dp__.exception_matches(__dp__.current_exception(), ValueError$0):
                exc = __dp__.current_exception()
                try:
                    raise __dp__.raise_from(RuntimeError$0("wrapped"), exc)
                finally:
                    try:
                        del exc
                    except:
                        if __dp__.exception_matches(__dp__.current_exception(), NameError$0):
                            pass
                        else:
                            raise
            else:
                raise
    except:
        if __dp__.exception_matches(__dp__.current_exception(), RuntimeError$0):
            pass
        else:
            raise
    finally:
        __dp__.setattr(builtins$0, "__import__", original_import)
    _dp_target_1 = __dp__.is_(sys$0.modules.get("asyncio"), package)
    return _dp_target_1
ASYNCIO_SHADOWED = raise_from_with_import_patch()

$ integration: mock class property

from unittest import mock


def mock_class_property_ok():
    m = mock.Mock(spec=int)
    return isinstance(m, int)


RESULT = mock_class_property_ok()
=
_dp_import_1 = __dp__.import_("unittest", __spec__, __dp__.list(("mock",)))
mock = __dp__.import_attr(_dp_import_1, "mock")
del _dp_import_1
def mock_class_property_ok():
    m = mock$0.Mock(spec=int$0)
    return isinstance$0(m, int$0)
RESULT = mock_class_property_ok()

$ integration: traceback linecache source

import traceback

class Boom:
    def explode(self):
        raise RuntimeError("boom")

def get_traceback():
    try:
        Boom().explode()
    except RuntimeError:
        return traceback.format_exc()
=
traceback = __dp__.import_("traceback", __spec__)
def _dp_ns_Boom(_dp_class_ns):

    def _dp_lambda_1():
        return __name__$0
    _dp_lambda_1 = __dp__.update_fn(_dp_lambda_1, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_1))
    __dp__.setattr(_dp_class_ns, "__qualname__", "Boom")

    def explode(self):
        raise RuntimeError$0("boom")

    def _dp_lambda_2():
        return explode$0
    _dp_lambda_2 = __dp__.update_fn(_dp_lambda_2, None, "<lambda>")
    __dp__.setattr(_dp_class_ns, "explode", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "explode", _dp_lambda_2), "Boom", "<locals>"))
Boom = __dp__.create_class("Boom", _dp_ns_Boom, (), None)
def get_traceback():
    try:
        getattr$0(Boom$0(), "explode")()
    except:
        if __dp__.exception_matches(__dp__.current_exception(), RuntimeError$0):
            return traceback$0.format_exc()
        else:
            raise

$ integration: assert raises refcount

import sys
import unittest

def _boom():
    try:
        raise ValueError("boom")
    except ValueError:
        raise ValueError("boom")

def run():
    case = unittest.TestCase()
    before = sys.getrefcount(_boom)
    case.assertRaises(ValueError, _boom)
    return before, sys.getrefcount(_boom)
=
sys = __dp__.import_("sys", __spec__)
unittest = __dp__.import_("unittest", __spec__)
def _boom():
    try:
        raise ValueError$0("boom")
    except:
        if __dp__.exception_matches(__dp__.current_exception(), ValueError$0):
            raise ValueError$0("boom")
        else:
            raise
def run():
    case = unittest$0.TestCase()
    before = sys$0.getrefcount(_boom$0)
    case.assertRaises(ValueError$0, _boom$0)
    return before, sys$0.getrefcount(_boom$0)
