$ import_simple

import a

=

a = __dp__.import_("a", __spec__)

$ import_dotted_alias

import a.b as c

=

c = __dp__.import_attr(__dp__.import_("a.b", __spec__), "b")

$ import_from_alias

from pkg.mod import name as alias

=

_dp_import_1 = __dp__.import_("pkg.mod", __spec__, __dp__.list(("name",)))
alias = __dp__.import_attr(_dp_import_1, "name")
del _dp_import_1

$ decorator_function

@dec
def f():
    pass

=

@dec
def f():
    pass

$ assign_attr

obj.x = 1

=

__dp__.setattr(obj, "x", 1)

$ assign_subscript

obj[i] = v

=

__dp__.setitem(obj, i, v)

$ assign_tuple_unpack

a, b = it

=

try:
    _dp_tmp_1 = __dp__.unpack(it, (True, True))
    a = __dp__.getitem(_dp_tmp_1, 0)
    b = __dp__.getitem(_dp_tmp_1, 1)
finally:
    _dp_tmp_1 = None

$ assign_star_unpack

a, *b = it

=

try:
    _dp_tmp_1 = __dp__.unpack(it, (True, False))
    a = __dp__.getitem(_dp_tmp_1, 0)
    b = __dp__.list(__dp__.getitem(_dp_tmp_1, 1))
finally:
    _dp_tmp_1 = None

$ assign_multi_targets

a = b = f()

=

_dp_tmp_1 = f()
a = _dp_tmp_1
b = _dp_tmp_1

$ ann_assign_simple

x: int = 1

=

x: int
x = 1

$ ann_assign_attr

obj.x: int = 1

=

obj.x: int
__dp__.setattr(obj, "x", 1)

$ aug_assign_attr

obj.x += 1

=

__dp__.setattr(obj, "x", __dp__.iadd(obj.x, 1))

$ delete_mixed

del obj.x, obj[i], x

=

__dp__.delattr(obj, "x")
__dp__.delitem(obj, i)
del x

$ assert_no_msg

assert cond

=

if __debug__:
    if __dp__.not_(cond):
        raise __dp__.builtins.AssertionError

$ assert_with_msg

assert cond, "oops"

=

if __debug__:
    if __dp__.not_(cond):
        raise __dp__.builtins.AssertionError("oops")

$ raise_from

raise E from cause

=

raise __dp__.raise_from(E, cause)

$ try_except_typed

try:
    f()
except E as e:
    g(e)
except:
    h()

=

try:
    f()
except:
    if __dp__.exception_matches(__dp__.current_exception(), E):
        e = __dp__.current_exception()
        try:
            g(e)
        finally:
            try:
                del e
            except:
                if __dp__.exception_matches(__dp__.current_exception(), NameError):
                    pass
                else:
                    raise
    else:
        h()

$ for_else

for x in it:
    body()
else:
    done()

=

_dp_iter_1 = __dp__.iter(it)
_dp_is_complete_2 = False
try:
    while True:
        x = __dp__.next(_dp_iter_1)
        body()
except:
    if __dp__.exception_matches(__dp__.current_exception(), StopIteration):
        _dp_is_complete_2 = True
    else:
        raise
if _dp_is_complete_2:
    done()

$ while_else

while cond:
    body()
else:
    done()

=

while True:
    _dp_test_flag_1 = cond
    if __dp__.not_(_dp_test_flag_1):
        break
    body()
if _dp_test_flag_1:
    done()

$ with_as

with cm as x:
    body()

=

_dp_tmp_3 = __dp__.with_enter(cm)
try:
    _dp_tmp_4 = __dp__.unpack(_dp_tmp_3, (True, True))
    x = __dp__.getitem(_dp_tmp_4, 0)
    _dp_with_exit_1 = __dp__.getitem(_dp_tmp_4, 1)
finally:
    _dp_tmp_4 = None
    _dp_tmp_3 = None
_dp_with_ok_2 = True
try:
    body()
except:
    _dp_with_ok_2 = False
    __dp__.with_exit(_dp_with_exit_1, __dp__.exc_info())
finally:
    if _dp_with_ok_2:
        __dp__.with_exit(_dp_with_exit_1, None)
    _dp_with_exit_1 = None

$ function_local_ann_assign

def inner():
    value: int = 1
    return value

=

def inner():
    value = 1
    return value

$ comprehension_global

xs = [x for x in it]
ys = {x for x in it}
zs = {k: v for k, v in items}

=

def _dp_comp_1(_dp_iter_2):
    _dp_result_3 = __dp__.list()
    _dp_iter_4 = __dp__.iter(_dp_iter_2)
    try:
        while True:
            x = __dp__.next(_dp_iter_4)
            _dp_result_3.append(x)
    except:
        if __dp__.exception_matches(__dp__.current_exception(), StopIteration):
            pass
        else:
            raise
    return _dp_result_3
xs = _dp_comp_1(it)
def _dp_comp_5(_dp_iter_6):
    _dp_result_7 = __dp__.set()
    _dp_iter_8 = __dp__.iter(_dp_iter_6)
    try:
        while True:
            x = __dp__.next(_dp_iter_8)
            _dp_result_7.add(x)
    except:
        if __dp__.exception_matches(__dp__.current_exception(), StopIteration):
            pass
        else:
            raise
    return _dp_result_7
ys = _dp_comp_5(it)
def _dp_comp_9(_dp_iter_10):
    _dp_result_11 = __dp__.dict()
    _dp_iter_12 = __dp__.iter(_dp_iter_10)
    try:
        while True:
            _dp_tmp_13 = __dp__.next(_dp_iter_12)
            try:
                _dp_tmp_14 = __dp__.unpack(_dp_tmp_13, (True, True))
                k = __dp__.getitem(_dp_tmp_14, 0)
                v = __dp__.getitem(_dp_tmp_14, 1)
            finally:
                _dp_tmp_14 = None
                _dp_tmp_13 = None
            __dp__.setitem(_dp_result_11, k, v)
    except:
        if __dp__.exception_matches(__dp__.current_exception(), StopIteration):
            pass
        else:
            raise
    return _dp_result_11
zs = _dp_comp_9(items)

$ comprehension_in_function

def f():
    return [x for x in it if x > 0]

=

def f():
    _dp_target_1 = __dp__.gt(x, 0)

    def _dp_comp_2(_dp_iter_3):
        _dp_result_4 = __dp__.list()
        _dp_iter_5 = __dp__.iter(_dp_iter_3)
        try:
            while True:
                x = __dp__.next(_dp_iter_5)
                if _dp_target_1:
                    _dp_result_4.append(x)
        except:
            if __dp__.exception_matches(__dp__.current_exception(), StopIteration):
                pass
            else:
                raise
        return _dp_result_4
    return _dp_comp_2(it)

$ comprehension_in_class_body

class C:
    xs = [x for x in it]

=

def _dp_class_create_C():

    def _dp_class_ns_C(_dp_class_ns, __classcell__):
        __dp__.setitem(_dp_class_ns, "__module__", __dp__.class_lookup_cell(_dp_class_ns, "__name__", __name__))
        __dp__.setitem(_dp_class_ns, "__qualname__", "C")

        def _dp_comp_2(_dp_iter_3):
            _dp_result_4 = __dp__.list()
            _dp_iter_5 = __dp__.iter(_dp_iter_3)
            try:
                while True:
                    x = __dp__.next(_dp_iter_5)
                    _dp_result_4.append(__dp__.class_lookup_cell(_dp_class_ns, "x", x))
            except:
                if __dp__.exception_matches(__dp__.current_exception(), StopIteration):
                    pass
                else:
                    raise
            return _dp_result_4
        __dp__.setitem(_dp_class_ns, "xs", _dp_comp_2(__dp__.class_lookup_cell(_dp_class_ns, "it", it)))

        def __annotate__(_dp_format):
            _dp_target_1 = __dp__.gt(_dp_format, 2)
            if _dp_target_1:
                raise NotImplementedError$0
            _dp_annotations = __dp__.dict()
            return _dp_annotations
        __dp__.update_fn(__annotate__$local, "C", "__annotate__")
        __dp__.setitem(_dp_class_ns, "__annotate__", __annotate__$local)
    return __dp__.create_class("C", _dp_class_ns_C, (), None, False)
C = _dp_class_create_C()

$ with_multi

with a as x, b as y:
    body()

=

_dp_tmp_5 = __dp__.with_enter(a)
try:
    _dp_tmp_6 = __dp__.unpack(_dp_tmp_5, (True, True))
    x = __dp__.getitem(_dp_tmp_6, 0)
    _dp_with_exit_3 = __dp__.getitem(_dp_tmp_6, 1)
finally:
    _dp_tmp_6 = None
    _dp_tmp_5 = None
_dp_with_ok_4 = True
try:
    _dp_tmp_7 = __dp__.with_enter(b)
    try:
        _dp_tmp_8 = __dp__.unpack(_dp_tmp_7, (True, True))
        y = __dp__.getitem(_dp_tmp_8, 0)
        _dp_with_exit_1 = __dp__.getitem(_dp_tmp_8, 1)
    finally:
        _dp_tmp_8 = None
        _dp_tmp_7 = None
    _dp_with_ok_2 = True
    try:
        body()
    except:
        _dp_with_ok_2 = False
        __dp__.with_exit(_dp_with_exit_1, __dp__.exc_info())
    finally:
        if _dp_with_ok_2:
            __dp__.with_exit(_dp_with_exit_1, None)
        _dp_with_exit_1 = None
except:
    _dp_with_ok_4 = False
    __dp__.with_exit(_dp_with_exit_3, __dp__.exc_info())
finally:
    if _dp_with_ok_4:
        __dp__.with_exit(_dp_with_exit_3, None)
    _dp_with_exit_3 = None

$ async_for

async def run():
    async for x in ait:
        body()

=

async def run():
    _dp_iter_1 = __dp__.aiter(ait)
    try:
        while True:
            x = await __dp__.anext(_dp_iter_1)
            body()
    except:
        if __dp__.exception_matches(__dp__.current_exception(), StopAsyncIteration):
            pass
        else:
            raise

$ async_with

async def run():
    async with cm as x:
        body()

=

async def run():
    _dp_tmp_3 = await __dp__.with_aenter(cm)
    try:
        _dp_tmp_4 = __dp__.unpack(_dp_tmp_3, (True, True))
        x = __dp__.getitem(_dp_tmp_4, 0)
        _dp_with_exit_1 = __dp__.getitem(_dp_tmp_4, 1)
    finally:
        _dp_tmp_4 = None
        _dp_tmp_3 = None
    _dp_with_ok_2 = True
    try:
        body()
    except:
        _dp_with_ok_2 = False
        await __dp__.with_aexit(_dp_with_exit_1, __dp__.exc_info())
    finally:
        if _dp_with_ok_2:
            await __dp__.with_aexit(_dp_with_exit_1, None)
        _dp_with_exit_1 = None

$ match_simple

match value:
    case 1:
        one()
    case _:
        other()

=

_dp_match_1 = value
_dp_target_2 = __dp__.eq(_dp_match_1, 1)
if _dp_target_2:
    one()
else:
    other()

$ generator_yield

def gen():
    yield 1

=

def gen():
    yield 1

$ yield_from

def gen():
    yield from it

=

def gen():
    yield from it

$ with_exit_suppresses_exception

with Suppress():
    raise RuntimeError("boom")

=

_dp_tmp_3 = __dp__.with_enter(Suppress())
try:
    _dp_tmp_4 = __dp__.unpack(_dp_tmp_3, (True, True))
    _ = __dp__.getitem(_dp_tmp_4, 0)
    _dp_with_exit_1 = __dp__.getitem(_dp_tmp_4, 1)
finally:
    _dp_tmp_4 = None
    _dp_tmp_3 = None
_dp_with_ok_2 = True
try:
    raise RuntimeError("boom")
except:
    _dp_with_ok_2 = False
    __dp__.with_exit(_dp_with_exit_1, __dp__.exc_info())
finally:
    if _dp_with_ok_2:
        __dp__.with_exit(_dp_with_exit_1, None)
    _dp_with_exit_1 = None

$ closure_cell_simple

def outer():
    x = 5
    def inner():
        return x
    return inner()

=

def outer():
    x = 5

    def inner():
        return x
    return inner()

$ closure_cell_nonlocal

def outer():
    x = 5
    def inner():
        nonlocal x
        x = 2
        return x
    return inner()

=

def outer():
    x = 5

    def inner():
        nonlocal x
        x = 2
        return x
    return inner()
