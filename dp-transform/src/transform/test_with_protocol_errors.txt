$ with protocol errors

from __future__ import annotations


def exercise():
    class LacksEnter:
        def __exit__(self, *exc_info):
            pass

    class LacksExit:
        def __enter__(self):
            return self

    errors = []
    for ctx in (LacksEnter(), LacksExit()):
        try:
            with ctx:
                pass
        except Exception as exc:
            errors.append((type(exc), str(exc)))
        else:
            errors.append(None)

    return errors
=
def exercise():

    def _dp_ns_LacksEnter(_dp_class_ns):

        def _dp_lambda_5():
            return __name__$0
        _dp_lambda_5 = __dp__.update_fn(_dp_lambda_5, "exercise.<locals>", "<lambda>")
        __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_5))
        __dp__.setattr(_dp_class_ns, "__qualname__", "exercise.<locals>.LacksEnter")

        def __exit__(self, *exc_info):
            pass

        def _dp_lambda_6():
            return __exit__$0
        _dp_lambda_6 = __dp__.update_fn(_dp_lambda_6, "exercise.<locals>", "<lambda>")
        __dp__.setattr(_dp_class_ns, "__exit__", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "__exit__", _dp_lambda_6), "exercise.<locals>.LacksEnter", "<locals>"))
    LacksEnter = __dp__.create_class("LacksEnter", _dp_ns_LacksEnter, (), None)

    def _dp_ns_LacksExit(_dp_class_ns):

        def _dp_lambda_7():
            return __name__$0
        _dp_lambda_7 = __dp__.update_fn(_dp_lambda_7, "exercise.<locals>", "<lambda>")
        __dp__.setattr(_dp_class_ns, "__module__", __dp__.class_lookup(_dp_class_ns, "__name__", _dp_lambda_7))
        __dp__.setattr(_dp_class_ns, "__qualname__", "exercise.<locals>.LacksExit")

        def __enter__(self):
            return self

        def _dp_lambda_8():
            return __enter__$0
        _dp_lambda_8 = __dp__.update_fn(_dp_lambda_8, "exercise.<locals>", "<lambda>")
        __dp__.setattr(_dp_class_ns, "__enter__", __dp__.update_fn(__dp__.class_lookup(_dp_class_ns, "__enter__", _dp_lambda_8), "exercise.<locals>.LacksExit", "<locals>"))
    LacksExit = __dp__.create_class("LacksExit", _dp_ns_LacksExit, (), None)
    errors = __dp__.list(())
    _dp_iter_1 = __dp__.iter((LacksEnter(), LacksExit()))
    try:
        while True:
            ctx = __dp__.next(_dp_iter_1)
            try:
                _dp_tmp_3 = __dp__.with_enter(ctx)
                try:
                    _dp_tmp_4 = __dp__.unpack(_dp_tmp_3, (True, True))
                    _ = __dp__.getitem(_dp_tmp_4, 0)
                    _dp_with_exit_2 = __dp__.getitem(_dp_tmp_4, 1)
                finally:
                    _dp_tmp_4 = None
                    _dp_tmp_3 = None
                try:
                    pass
                except:
                    __dp__.with_exit(_dp_with_exit_2, __dp__.exc_info())
                else:
                    __dp__.with_exit(_dp_with_exit_2, None)
                finally:
                    _dp_with_exit_2 = None
            except:
                if __dp__.exception_matches(__dp__.current_exception(), Exception$0):
                    exc = __dp__.current_exception()
                    try:
                        errors.append((type$0(exc), str$0(exc)))
                    finally:
                        try:
                            del exc
                        except:
                            if __dp__.exception_matches(__dp__.current_exception(), NameError$0):
                                pass
                            else:
                                raise
                else:
                    raise
            else:
                errors.append(None)
    except:
        if __dp__.exception_matches(__dp__.current_exception(), StopIteration$0):
            pass
        else:
            raise
    return errors
